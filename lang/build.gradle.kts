/**
 * Root project for XTC language tooling.
 *
 * Subprojects:
 * - dsl: Language model DSL and editor support generators
 * - lsp-server: Language Server Protocol implementation
 * - intellij-plugin: IntelliJ IDEA plugin
 * - vscode-extension: VS Code extension
 */

plugins {
    base
    alias(libs.plugins.kotlin.jvm) apply false
    alias(libs.plugins.kotlin.serialization) apply false
    alias(libs.plugins.ktlint) apply false
}

// =============================================================================
// Update generated-examples directory
// =============================================================================
//
// The generated-examples directory contains output from the editor support
// generators. These files ARE generated by the build, but are committed to
// source control in a well-defined location for two reasons:
//
// 1. Experimentation: Users can explore syntax highlighting definitions for
//    various editors (Vim, Emacs, VS Code, Sublime, Tree-sitter) without
//    needing to set up and build the entire project.
//
// 2. Reference: The examples serve as documentation showing what the language
//    model DSL produces for each target editor format.
//
// Run `./gradlew :lang:updateGeneratedExamples` to regenerate these files
// after modifying the language model or generators.
// =============================================================================

val updateGeneratedExamples by tasks.registering(Copy::class) {
    group = "generation"
    description = "Update the generated-examples directory with freshly generated files"

    dependsOn(project(":dsl").tasks.named("generateEditorSupport"))

    from(project(":dsl").layout.buildDirectory.dir("generated")) {
        include("xtc.tmLanguage.json")
        include("language-configuration.json")
        include("xtc.vim")
        include("xtc-mode.el")
        include("grammar.js")
        include("highlights.scm")
        include("xtc.sublime-syntax")
    }

    into(layout.projectDirectory.dir("generated-examples"))
}

// =============================================================================
// Aggregate subproject tasks
// =============================================================================

val build by tasks.existing {
    dependsOn(project(":dsl").tasks.named("build"))
    dependsOn(project(":lsp-server").tasks.named("build"))
    dependsOn(project(":intellij-plugin").tasks.named("buildPlugin"))
}

val assemble by tasks.existing {
    dependsOn(project(":dsl").tasks.named("assemble"))
    dependsOn(project(":lsp-server").tasks.named("assemble"))
    dependsOn(project(":intellij-plugin").tasks.named("assemble"))
}

val check by tasks.existing {
    dependsOn(project(":dsl").tasks.named("check"))
    dependsOn(project(":lsp-server").tasks.named("check"))
    dependsOn(project(":intellij-plugin").tasks.named("check"))
}

val clean by tasks.existing {
    dependsOn(project(":dsl").tasks.named("clean"))
    dependsOn(project(":lsp-server").tasks.named("clean"))
    dependsOn(project(":intellij-plugin").tasks.named("clean"))
    dependsOn(project(":vscode-extension").tasks.named("clean"))
}

// =============================================================================
// IDE run tasks - convenience aliases for subproject tasks
// =============================================================================

// Access parent build's included builds for publishing before runIde.
// This ensures the latest XTC Gradle plugin is available in local Maven before the sandbox IDE starts,
// so Run Configurations can use the current --module, --method, --args command-line options.
val parentPublishLocal = gradle.parent?.let { parent ->
    listOf(
        parent.includedBuild("xdk").task(":publishToMavenLocal"),
        parent.includedBuild("plugin").task(":publishToMavenLocal")
    )
} ?: emptyList()

val runIntellijPlugin by tasks.registering {
    group = "run"
    description = "Launch IntelliJ IDEA with the XTC plugin loaded for testing"
    parentPublishLocal.forEach { dependsOn(it) }
    dependsOn(project(":intellij-plugin").tasks.named("runIde"))
}

val runVsCodeExtension by tasks.registering {
    group = "run"
    description = "Launch VS Code with the XTC extension loaded for testing"
    dependsOn(project(":vscode-extension").tasks.named("runCode"))
}

