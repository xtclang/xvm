import org.jlleitschuh.gradle.ktlint.KtlintExtension

/**
 * Root project for XTC language tooling.
 *
 * Subprojects:
 * - dsl: Language model DSL and editor support generators
 * - lsp-server: Language Server Protocol implementation
 * - intellij-plugin: IntelliJ IDEA plugin
 * - vscode-extension: VS Code extension
 */

plugins {
    base
    alias(libs.plugins.lang.kotlin.jvm) apply false
    alias(libs.plugins.lang.kotlin.serialization) apply false
    alias(libs.plugins.lang.ktlint) apply false
}

// =============================================================================
// ktlint configuration for all Kotlin subprojects
// =============================================================================
// Centralized ktlint setup: pins the engine version and ensures auto-formatting
// runs before checks, so developers never see formatting-only failures.
// Rule configuration lives in lang/.editorconfig (picked up automatically).

subprojects {
    pluginManager.withPlugin("org.jlleitschuh.gradle.ktlint") {
        configure<KtlintExtension> {
            // Pin the ktlint engine version (from libs.versions.toml) to ensure
            // consistent formatting across environments, independent of which
            // Gradle plugin version is used.
            version.set(libs.versions.lang.ktlint.engine)

            // --- Uncomment to override defaults ---
            // verbose.set(false)
            // debug.set(false)
            // android.set(false)
            // outputToConsole.set(true)
            // coloredOutput.set(true)
            // outputColorName.set("")
            // ignoreFailures.set(false)
            // enableExperimentalRules.set(false)
            // relative.set(false)
            // baseline.set(file("config/ktlint/baseline.xml"))
        }

        // Auto-format before check: both lifecycle tasks (ktlint*Check) and their
        // underlying worker tasks (runKtlintCheckOver*) must wait for formatting to
        // complete. Without wiring the worker tasks, Gradle can schedule them before
        // the format workers finish writing corrected files.
        tasks.matching { it.name.startsWith("ktlint") && it.name.endsWith("Check") }.configureEach {
            val formatTaskName = name.replace("Check", "Format")
            dependsOn(tasks.named(formatTaskName))
        }
        tasks.matching { it.name.startsWith("runKtlintCheck") }.configureEach {
            val formatTaskName = name.replace("runKtlintCheck", "runKtlintFormat")
            dependsOn(tasks.named(formatTaskName))
        }
    }
}


// =============================================================================
// Update generated-examples directory
// =============================================================================
//
// The generated-examples directory contains output from the editor support
// generators. These files ARE generated by the build, but are committed to
// source control in a well-defined location for two reasons:
//
// 1. Experimentation: Users can explore syntax highlighting definitions for
//    various editors (Vim, Emacs, VS Code, Sublime, Tree-sitter) without
//    needing to set up and build the entire project.
//
// 2. Reference: The examples serve as documentation showing what the language
//    model DSL produces for each target editor format.
//
// Run `./gradlew :lang:updateGeneratedExamples` to regenerate these files
// after modifying the language model or generators.
// =============================================================================

val updateGeneratedExamples by tasks.registering(Copy::class) {
    group = "generation"
    description = "Update the generated-examples directory with freshly generated files"

    dependsOn(project(":dsl").tasks.named("generateEditorSupport"))

    from(project(":dsl").layout.buildDirectory.dir("generated")) {
        include("xtc.tmLanguage.json")
        include("language-configuration.json")
        include("xtc.vim")
        include("xtc-mode.el")
        include("grammar.js")
        include("highlights.scm")
        include("xtc.sublime-syntax")
    }

    into(layout.projectDirectory.dir("generated-examples"))
}

// =============================================================================
// Aggregate subproject tasks
// =============================================================================

// Projects to aggregate standard lifecycle tasks from
val coreProjects = listOf(":dsl", ":tree-sitter", ":lsp-server", ":debug-adapter", ":intellij-plugin")
val allProjects = coreProjects + ":vscode-extension"

// Map of aggregate task -> subproject task (null means same name)
val taskMappings = mapOf(
    "build" to mapOf(":intellij-plugin" to "buildPlugin"),  // intellij uses buildPlugin
    "assemble" to emptyMap(),
    "check" to emptyMap(),
    "clean" to emptyMap()
)

taskMappings.forEach { (aggregateTask, overrides) ->
    val projects = if (aggregateTask == "clean") allProjects else coreProjects
    tasks.named(aggregateTask) {
        projects.forEach { proj ->
            val subTask = overrides[proj] ?: aggregateTask
            dependsOn(project(proj).tasks.named(subTask))
        }
    }
}

// =============================================================================
// IDE run tasks - convenience aliases for subproject tasks
// =============================================================================

val runIntellijPlugin by tasks.registering {
    group = "run"
    description = "Launch IntelliJ IDEA with the XTC plugin loaded for testing"
    dependsOn(project(":intellij-plugin").tasks.named("runIde"))
}

val runVsCodeExtension by tasks.registering {
    group = "run"
    description = "Launch VS Code with the XTC extension loaded for testing"
    dependsOn(project(":vscode-extension").tasks.named("runCode"))
}
