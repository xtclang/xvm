/**
e * Tree-sitter grammar for {{LANGUAGE_NAME}}
 * Generated from XTC language model
 */

module.exports = grammar({
    name: 'xtc',

    // Note: doc_comment is NOT in extras - it's an explicit optional prefix to declarations.
    // This prevents tree-sitter's GLR parser from misidentifying keywords after doc comments.
    // Only whitespace and non-doc comments are extras (can appear anywhere).
    extras: $ => [
        /\s/,
        $.line_comment,
        $.block_comment,
    ],

    externals: $ => [],

    // Conflicts that need explicit declaration:
    // 1. unary vs binary vs call: `+expr<T>()` - is `<` comparison or type arg?
    // 2. binary vs call: `a..b<T>()` - `<` could be comparison or type arg
    // 3. list vs map literal: `[]` could be empty list or empty map
    // 4. array_type vs conditional_type: `conditional T[]` - is [] on conditional or on T?
    // 5. _non_bi_type conflicts with union/intersection types
    // 6. type_expression vs tuple_type in contexts like typedef (Type1 | Type2) as Name
    // The parser resolves these by preferring the higher precedence rule
    conflicts: $ => [
        [$.binary_expression, $.unary_expression, $.call_expression],
        [$.binary_expression, $.call_expression],
        [$.list_literal, $.map_literal],
        [$.array_type, $.conditional_type],
        [$.nullable_type, $.conditional_type],
        [$._expression, $.type_name],
        [$.member_expression, $.qualified_type_name],
        [$.type_name, $.qualified_type_name],
        [$.member_type, $.qualified_type_name],
        [$.generic_type, $.member_type],
        [$._expression, $.qualified_type_name],
        [$._expression, $.type_name, $.qualified_type_name],
        [$.union_type, $._non_bi_type],
        [$.intersection_type, $._non_bi_type],
        [$.difference_type, $._non_bi_type],
        [$.type_expression, $.tuple_type],
        [$.tuple_expression, $.tuple_type],
        [$.parenthesized_type, $.tuple_type],
        [$.immutable_type, $.array_type],
        [$.immutable_type, $.nullable_type],
        [$.non_null_type, $.conditional_type],
        [$.immutable_type, $.non_null_type],
        [$.non_null_type, $.postfix_expression],
        [$.class_declaration, $.keyword_type],
        [$.service_declaration, $.keyword_type],
        [$.const_declaration, $.keyword_type],
        [$.enum_declaration, $.keyword_type],
        [$.conditional_declaration, $._expression],
        [$.switch_statement, $.switch_expression],
        [$.case_pattern, $._expression],
        [$.pattern_element, $._expression],
        [$.tuple_pattern, $.parenthesized_expression],
        [$.pattern_element, $.parenthesized_expression],
        [$.new_expression, $.member_expression],
        [$.unary_expression, $.member_expression, $.new_expression],
        [$.assignment_expression, $.member_expression, $.new_expression],
        [$.binary_expression, $.member_expression, $.new_expression],
        [$.binary_expression, $.unary_expression, $.member_expression, $.new_expression],
        [$.ternary_expression, $.member_expression, $.new_expression],
        [$.expression_case_clause, $.case_clause],
        [$.expression_case_clause, $.expression_statement],
        [$.assert_condition, $._expression],
        [$.pattern_element, $.tuple_expression],
        [$.throw_expression, $.binary_expression],
        [$.throw_statement, $.throw_expression],
        [$.assert_statement, $.assert_expression],
        [$._expression, $.type_expression],
        [$.variable_declaration, $.expression_statement],
        [$.variable_declaration, $._expression],
        [$.labeled_statement, $.variable_declaration],
        [$.labeled_statement, $.type_name],
        [$.labeled_statement, $.qualified_type_name],
        [$.tuple_assignment, $.expression_statement],
        [$.tuple_assignment_element, $._expression],
        [$.tuple_assignment_element, $.tuple_expression],
        [$.tuple_assignment_element, $.parameter],
        [$.for_tuple_destructure, $.tuple_expression],
        [$.for_tuple_destructure, $.parameters],
        [$.for_tuple_destructure, $.parameter],
        [$.conditional_tuple_pattern, $.for_tuple_destructure],
        [$.conditional_tuple_pattern, $.tuple_expression],
        [$.conditional_tuple_pattern, $.parameters],
        [$.conditional_tuple_pattern, $.parameter],
        [$.if_condition, $._expression],
        [$.type_expression, $.array_type],
        [$.function_type_parameters, $.tuple_type],
        [$.tuple_type_element, $.parameter],
        [$.tuple_type_element, $.type_expression],
        [$.conditional_type, $.function_type],
        [$.conditional_type, $.named_function_type],
        [$.parameter, $.named_function_type],
        [$.incorporates_clause, $.conditional_type],
        [$._non_bi_type, $.generic_type],
        [$.named_argument, $._expression],
        [$.switch_variable_declaration, $._expression],
        [$.ternary_expression, $.else_expression],
        [$.else_expression, $.throw_expression],
        [$.else_expression, $.ternary_expression, $.member_expression, $.new_expression],
        [$.case_pattern, $.else_expression],
        [$.postfix_expression, $.ternary_expression],
        [$.ternary_expression, $.binary_expression, $.postfix_expression],
        [$.case_pattern, $.typed_literal],
        [$.statement_expression, $._statement],
    ],

    word: $ => $.identifier,

    rules: {
        // Source file
        source_file: $ => repeat($._definition),

        // Definitions
        _definition: $ => choice(
            $.module_declaration,
            $.package_declaration,
            $.import_statement,
            $.class_declaration,
            $.interface_declaration,
            $.mixin_declaration,
            $.service_declaration,
            $.const_declaration,
            $.enum_declaration,
            $.typedef_declaration,
            $.annotation_declaration,
        ),

        // Module declaration
        // Note: doc_comment is optional prefix, not in extras, to avoid keyword recognition issues
        module_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            'module',
            $.qualified_name,
            optional($.module_body),
        ),

        module_body: $ => seq('{', repeat($._definition), '}'),

        // Package declaration
        // Note: Package must end with either a body { } or semicolon ;
        // This resolves the ambiguity between inline import_spec and standalone import_statement
        // Examples: "package foo;" or "package foo { }" or "package foo import bar.baz;"
        package_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            'package',
            $.identifier,
            optional($.import_spec),
            choice($.package_body, ';'),
        ),

        package_body: $ => seq('{', repeat($._definition), '}'),

        // Import
        import_statement: $ => seq(
            'import',
            $.qualified_name,
            optional(seq('as', $.identifier)),
            ';',
        ),

        import_spec: $ => seq('import', $.qualified_name),

        // Class declaration
        // Note: XTC allows multiple implements clauses, e.g.:
        //   class Foo implements A implements B implements C
        // Also allows annotations to appear after static: protected static @Abstract class
        // The extends/implements/incorporates clauses can appear in any order
        // Classes can end with either a body { } or semicolon ; (for simple extension classes)
        class_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            optional(seq('static', repeat($.annotation))),
            optional('abstract'),
            'class',
            $.type_name,
            optional($.type_parameters),
            optional($.constructor_parameters),
            repeat(choice($.extends_clause_with_args, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
            choice($.class_body, ';'),
        ),

        // Similar declarations
        // Interfaces can end with either a body { } or semicolon ;
        interface_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            optional('static'),
            'interface',
            $.type_name,
            optional($.type_parameters),
            repeat($.extends_clause),
            choice($.class_body, ';'),
        ),

        // Mixin can end with body or semicolon (for simple mixins)
        mixin_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            optional('static'),
            'mixin',
            $.type_name,
            optional($.type_parameters),
            optional($.constructor_parameters),
            repeat(choice($.into_clause, $.extends_clause, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
            choice($.class_body, ';'),
        ),

        // Service can end with body or semicolon
        service_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            'service',
            $.type_name,
            optional($.type_parameters),
            optional($.constructor_parameters),
            repeat(choice($.extends_clause, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
            choice($.class_body, ';'),
        ),

        // Const declaration allows annotations to appear after static: static @Abstract const
        const_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            optional(seq('static', repeat($.annotation))),
            'const',
            $.type_name,
            optional($.type_parameters),
            optional($.constructor_parameters),
            repeat(choice($.extends_clause_with_args, $.implements_clause, $.incorporates_clause, $.delegates_clause, $.default_clause)),
            choice($.class_body, ';'),
        ),

        enum_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            'enum',
            $.type_name,
            optional($.type_parameters),
            optional($.constructor_parameters),
            optional($.enum_default_clause),
            repeat($.implements_clause),
            repeat($.incorporates_clause),
            $.enum_body,
        ),

        constructor_parameters: $ => $.parameters,
        enum_default_clause: $ => seq('default', $.arguments),
        // Default clause for const types: default(value)
        default_clause: $ => seq('default', $.arguments),

        // Typedef: typedef Type as Name;
        typedef_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            'typedef',
            $.type_expression,
            'as',
            $.identifier,
            ';',
        ),

        // Annotation declaration: annotation Name into TargetType implements Interface { ... }
        // XTC annotations are similar to mixins but use 'annotation' keyword and 'into' clause
        annotation_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            'annotation',
            $.type_name,
            optional($.type_parameters),
            optional($.constructor_parameters),
            repeat(choice($.into_clause, $.extends_clause, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
            choice($.class_body, ';'),
        ),

        // Class body
        class_body: $ => seq('{', repeat($._class_member), '}'),

        enum_body: $ => seq(
            '{',
            optional($.enum_values),
            optional(seq(';', repeat($._class_member))),
            '}',
        ),

        enum_values: $ => seq($.enum_value, repeat(seq(',', $.enum_value)), optional(',')),

        // Enum values can have doc comments, arguments, and/or a body with methods
        enum_value: $ => seq(
            optional($.doc_comment),
            $.identifier,
            optional($.arguments),
            optional($.enum_value_body),
        ),

        enum_value_body: $ => seq('{', repeat($._class_member), '}'),

        // Class members
        _class_member: $ => choice(
            $.property_declaration,
            $.method_declaration,
            $.property_getter_declaration,
            $.constructor_declaration,
            $.assert_block,
            $.class_declaration,
            $.interface_declaration,
            $.const_declaration,
            $.enum_declaration,
            $.typedef_declaration,
            $.mixin_declaration,
            $.service_declaration,
        ),

        // Property declaration supports annotations before and/or after visibility
        // e.g., @Override public Int x; OR public/protected @Unassigned Key key;
        // Properties can have: simple value (;), initializer (= expr;), or a body with accessors ({ ... })
        property_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional(seq($.visibility_modifier, repeat($.annotation))),
            optional(seq('static', repeat($.annotation))),
            $.type_expression,
            $.identifier,
            choice(
                seq(optional(seq('=', $._expression)), ';'),
                $.property_body,
            ),
        ),

        // Property body: { getter/setter methods, nested classes, etc. }
        // This is similar to a class body but for properties
        property_body: $ => seq('{', repeat($._class_member), '}'),

        method_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional(seq($.visibility_modifier, repeat($.annotation))),
            optional(seq('static', repeat($.annotation))),
            optional('abstract'),
            optional($.type_parameters),
            $.type_expression,
            $.identifier,
            optional($.type_parameters),
            $.parameters,
            // Expression body can be: = expr; or = TODO text (no semicolon for TODO inline text)
            // prec(2) ensures TODO form is tried first
            choice($.block, prec(2, seq('=', $.todo_expression)), seq('=', $._expression, ';'), ';'),
        ),

        // Property accessor syntax: `Type propName.get() { ... }` or `Type propName.calc() = expr;`
        // Supports any accessor method name (get, set, calc, add, etc.)
        property_getter_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional(seq($.visibility_modifier, repeat($.annotation))),
            $.type_expression,
            $.identifier,
            '.',
            $.identifier,
            $.parameters,
            choice($.block, seq('=', $._expression, ';'), ';'),
        ),

        // Constructor can have optional finally block: construct(...) { } finally { }
        // prec.right prefers to attach 'finally' to current constructor rather than new declaration
        // Constructor can also be just a signature (ending with ;) in interfaces
        constructor_declaration: $ => prec.right(seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional($.visibility_modifier),
            choice('construct', 'finally'),
            $.parameters,
            choice(
                seq($.block, optional(seq('finally', $.block))),
                ';',
            ),
        )),

        // Assert block (in const classes): `assert() { ... }`
        assert_block: $ => seq(
            'assert',
            $.parameters,
            $.block,
        ),

        // Clauses
        extends_clause: $ => seq('extends', $.type_expression),
        extends_clause_with_args: $ => seq('extends', $.type_expression, optional($.arguments)),
        implements_clause: $ => seq('implements', commaSep1($.type_expression)),
        // Incorporates can be conditional: incorporates conditional Mixin<Type extends Constraint>
        // Uses $._non_bi_type after 'conditional' to avoid conflict with conditional_type in type_expression
        incorporates_clause: $ => choice(
            seq('incorporates', 'conditional', $._non_bi_type, optional($.arguments)),
            seq('incorporates', $.type_expression, optional($.arguments)),
        ),
        // Delegates clause: delegates Type(expr)
        delegates_clause: $ => seq('delegates', $.type_expression, '(', $._expression, ')'),
        into_clause: $ => seq('into', $.type_expression),

        // Type parameters
        type_parameters: $ => seq('<', commaSep1($.type_parameter), '>'),
        type_parameter: $ => seq($.identifier, optional(seq('extends', $.type_expression))),

        // Parameters (with optional trailing comma)
        parameters: $ => seq('(', commaSep($.parameter), optional(','), ')'),
        // Parameters can be:
        // - Regular: Type name = default
        // - Named function type: function ReturnType name(ParamTypes) = default
        //   The named function type form includes the name already
        parameter: $ => choice(
            seq($.named_function_type, optional(seq('=', $._expression))),
            seq($.type_expression, $.identifier, optional(seq('=', $._expression))),
        ),

        // Type expressions
        // Note: array_type uses prec.left to greedily consume [] after types
        // Includes 'void' as a special primitive type (lowercase)
        // Union (|), intersection (+), and difference (-) types have lowest precedence
        type_expression: $ => choice(
            $.union_type,
            $.intersection_type,
            $.difference_type,
            $._non_bi_type,
        ),

        // Binary type operations - union binds looser than intersection/difference
        union_type: $ => prec.left(1, seq($._non_bi_type, '|', $.type_expression)),
        intersection_type: $ => prec.left(2, seq($._non_bi_type, '+', $.type_expression)),
        difference_type: $ => prec.left(2, seq($._non_bi_type, '-', $.type_expression)),

        // Non-binary type expressions (no | or + or -)
        _non_bi_type: $ => choice(
            $.type_name,
            $.primitive_type,
            $.generic_type,
            $.member_type,
            $.array_type,
            $.nullable_type,
            $.non_null_type,
            $.conditional_type,
            $.function_type,
            $.tuple_type,
            $.immutable_type,
            $.parenthesized_type,
            $.keyword_type,
        ),

        primitive_type: $ => 'void',
        keyword_type: $ => choice('service', 'const', 'enum', 'module', 'package', 'class'),
        // immutable can be standalone or with a type. prec.right makes it greedy.
        immutable_type: $ => prec.right(seq('immutable', optional($._non_bi_type))),
        parenthesized_type: $ => seq('(', $.type_expression, ')'),

        // Generic type: Map<Key> or Map!<Key> (non-null generic)
        // The ! must come before type arguments: Name!<Args>, not Name<Args>!
        generic_type: $ => seq($.type_name, optional(token.immediate('!')), $.type_arguments),
        // Member type access: Type<Key>.MemberType or Package.TypeName
        // Used in typedef Type<Key>.Orderer as Orderer
        member_type: $ => prec.left(seq(choice($.generic_type, $.type_name), '.', $.identifier)),
        // Type arguments can include constraints: <Key, Value extends Shareable>
        // Can also include angle-bracket type lists for method signatures: Method<Target, <Params>, <Return>>
        // Can be empty: Class<> for wildcard/inferred type arguments
        type_arguments: $ => seq('<', commaSep($.type_argument), '>'),
        type_argument: $ => choice(
            $.angle_bracket_type_list,
            seq($.type_expression, optional(seq('extends', $.type_expression))),
        ),
        // Angle bracket type list: <> or <Type> or <Type1, Type2> - used in method type signatures
        angle_bracket_type_list: $ => seq('<', commaSep($.type_expression), '>'),
        array_type: $ => prec.left(seq($._non_bi_type, '[', ']')),
        nullable_type: $ => prec.left(seq($._non_bi_type, '?')),
        // Non-null type modifier (no auto-narrowing): Type!
        non_null_type: $ => prec.left(seq($._non_bi_type, token.immediate('!'))),
        conditional_type: $ => seq('conditional', $._non_bi_type),
        // Function type: function ReturnType(ParamTypes) - parameters are just types, no names
        // Function type: function ReturnType(ParamTypes)
        function_type: $ => seq('function', optional('conditional'), $._non_bi_type, $.function_type_parameters),
        function_type_parameters: $ => seq('(', commaSep($.type_expression), ')'),
        // Named function type: function ReturnType name(ParamTypes) - used only in parameter context
        // The name appears between return type and parameters
        named_function_type: $ => seq('function', optional('conditional'), $._non_bi_type, $.identifier, $.function_type_parameters),
        // Tuple type can be unnamed (Type1, Type2) or named (Type1 name1, Type2 name2)
        tuple_type: $ => seq('(', commaSep($.tuple_type_element), ')'),
        tuple_type_element: $ => seq($._non_bi_type, optional($.identifier)),

        // Statements
        block: $ => seq('{', repeat($._statement), '}'),

        _statement: $ => choice(
            $.block,
            $.labeled_statement,
            $.variable_declaration,
            $.tuple_assignment,
            $.if_statement,
            $.for_statement,
            $.while_statement,
            $.do_statement,
            $.switch_statement,
            $.try_statement,
            $.using_statement,
            $.return_statement,
            $.break_statement,
            $.continue_statement,
            $.assert_statement,
            $.throw_statement,
            $.construct_delegation,
            $.todo_statement,
            $.expression_statement,
            // Local imports (inside method bodies)
            $.import_statement,
            // Local type declarations (inner classes, interfaces, etc.)
            $.class_declaration,
            $.interface_declaration,
            $.const_declaration,
            $.enum_declaration,
            $.mixin_declaration,
            // Local function declarations (functions defined inside method bodies)
            $.local_function_declaration,
            // Local typedef (type aliases inside method bodies)
            $.typedef_declaration,
        ),

        // Local function declaration: visibility, static, return type, name, params, body
        // Supports: private static (String, String) decode(Entry entry) { ... }
        // Also supports doc comments before local functions
        // Annotations can appear after visibility modifier: private @Foo Type fn()
        local_function_declaration: $ => seq(
            optional($.doc_comment),
            repeat($.annotation),
            optional(seq($.visibility_modifier, repeat($.annotation))),
            optional(seq('static', repeat($.annotation))),
            optional($.type_parameters),
            $.type_expression,
            $.identifier,
            $.parameters,
            choice($.block, seq('=', $._expression, ';')),
        ),

        // Labeled statement: Label: for/while/do/switch/if/block
        // Higher precedence to prefer label interpretation over type_name
        labeled_statement: $ => prec(1, seq(
            $.identifier,
            ':',
            choice($.for_statement, $.while_statement, $.do_statement, $.switch_statement, $.if_statement, $.block),
        )),

        // Constructor delegation: construct ConstructorName(args);
        construct_delegation: $ => seq(
            'construct',
            $.type_name,
            $.arguments,
            ';',
        ),

        // Tuple assignment: (Type1 x, Type2 y) = expr; or (x, this.y) = expr;
        tuple_assignment: $ => seq(
            '(',
            $.tuple_assignment_element,
            repeat1(seq(',', $.tuple_assignment_element)),
            ')',
            '=',
            $._expression,
            ';',
        ),

        // Element in tuple assignment: can be typed (Type x) or untyped (x, this.y)
        tuple_assignment_element: $ => choice(
            seq($.type_expression, $.identifier),
            $._expression,
        ),

        // Statement implementations
        // Variable declarations can be:
        // - val x = expr;  or  var x = expr;  (with optional type)
        // - Type x = expr;  (explicit type without val/var)
        // - @Annotation Type x = expr;  (with annotations)
        // - private Type x = expr;  (with visibility modifier for local captures)
        // - static Type x = expr;  (local static property)
        variable_declaration: $ => choice(
            // val/var form: val x = expr or var Type x = expr
            seq(
                repeat($.annotation),
                optional($.visibility_modifier),
                choice('val', 'var'),
                optional($.type_expression),
                $.identifier,
                optional(seq(choice('=', ':='), $._expression)),
                ';',
            ),
            // Typed form without val/var: @Annotation private static Type x = expr;
            seq(
                repeat($.annotation),
                optional($.visibility_modifier),
                optional('static'),
                $.type_expression,
                $.identifier,
                optional(seq(choice('=', ':='), $._expression)),
                ';',
            ),
        ),

        // Conditional declaration: val x := expr or Type x := expr (used in if/while conditions)
        // Also supports: Type x ?= expr (not-null assignment)
        // Also supports tuple destructuring: (Type1 x, Type2 y) := expr
        conditional_declaration: $ => seq(
            choice(
                seq(choice('val', 'var'), optional($.type_expression), $.identifier),
                seq($.type_expression, $.identifier),
                $.conditional_tuple_pattern,
            ),
            choice(':=', '?='),
            $._expression,
        ),

        // Tuple pattern for conditional declaration: (Type1 x, Type2 y)
        conditional_tuple_pattern: $ => seq(
            '(',
            $.type_expression, $.identifier,
            repeat1(seq(',', $.type_expression, $.identifier)),
            ')',
        ),

        // Dangling else: `if (a) if (b) x else y` - else binds to nearest if (right associativity)
        // Supports conditional declaration: if (val x := expr) or if (Type x := expr)
        // Also supports multiple conditions: if (cond1, cond2, ...) where each can be expr or decl
        if_statement: $ => prec.right(seq(
            'if',
            '(',
            $.if_condition,
            repeat(seq(',', $.if_condition)),
            ')',
            $._statement,
            optional(seq('else', $._statement)),
        )),

        // A condition in an if/while statement: expression or conditional declaration
        if_condition: $ => choice($._expression, $.conditional_declaration),

        for_statement: $ => seq(
            'for',
            '(',
            choice(
                // for (val name : iterable) or for (var name : iterable) - prefer val/var keywords first
                prec(2, seq('val', $._identifier_or_context_keyword, ':', $._expression)),
                prec(2, seq('var', $._identifier_or_context_keyword, ':', $._expression)),
                // for (Type name : iterable)
                prec(1, seq($.type_expression, $._identifier_or_context_keyword, ':', $._expression)),
                seq($.for_tuple_destructure, ':', $._expression),
                // Traditional for loop: for (init; condition; update)
                // init can be a variable declaration (Type name = expr) or expression
                seq(optional($.for_initializer), ';', optional($._expression), ';', optional($._expression)),
            ),
            ')',
            $._statement,
        ),

        // For loop initializer: either an expression or variable declaration(s)
        // Supports multiple declarations: for (Int i = 0, Int c = size; ...)
        for_initializer: $ => choice(
            $.for_var_declarations,
            $._expression,
        ),
        // Multiple variable declarations in for initializer
        for_var_declarations: $ => seq(
            $.type_expression, $.identifier, '=', $._expression,
            repeat(seq(',', $.type_expression, $.identifier, '=', $._expression)),
        ),

        // Tuple destructuring pattern for for-each: ((Type1 name1, Type2 name2))
        for_tuple_destructure: $ => seq(
            '(',
            $.type_expression, $.identifier,
            repeat1(seq(',', $.type_expression, $.identifier)),
            ')',
        ),

        // Supports conditional declaration: while (Element x := expr)
        // Supports multiple conditions: while (cond1, cond2)
        while_statement: $ => seq('while', '(', $.if_condition, repeat(seq(',', $.if_condition)), ')', $._statement),
        do_statement: $ => seq('do', $._statement, 'while', '(', $._expression, ')', ';'),

        // Switch statement (traditional form with statements)
        // Can have inline variable declarations: switch (Type name = expr)
        switch_statement: $ => seq(
            'switch',
            '(',
            commaSep1(choice($.switch_variable_declaration, $._expression)),
            ')',
            '{',
            repeat($.case_clause),
            '}',
        ),

        // Switch expression (returns a value): switch (x) { case A: value; }
        // Can have inline variable declarations: switch (Type name = expr)
        switch_expression: $ => seq(
            'switch',
            '(',
            commaSep1(choice($.switch_variable_declaration, $._expression)),
            ')',
            '{',
            repeat($.expression_case_clause),
            '}',
        ),

        // Variable declaration inside switch expression: Type name = expr
        switch_variable_declaration: $ => seq($.type_expression, $.identifier, '=', $._expression),

        // Case clause for switch statements (can contain statements)
        // prec(5) ensures the ':' is consumed by case_clause, not by typed_literal (prec(2))
        // when the case pattern contains a generic type like 'case List<String>:'
        case_clause: $ => prec(5, seq(
            choice(seq('case', $.case_pattern), 'default'),
            ':',
            repeat($._statement),
        )),

        // Expression case clause for switch expressions (returns value with semicolon)
        // prec(5) ensures the ':' is consumed by the clause, not by typed_literal (prec(2))
        expression_case_clause: $ => prec(5, seq(
            choice(seq('case', $.case_pattern), 'default'),
            ':',
            $._expression,
            ';',
        )),

        // Case pattern: single expression, comma-separated expressions, type expression, or tuple pattern
        // Supports: case 'P', 'p':  (multiple values in one case)
        // Supports: case List<String>: (type pattern matching)
        // Type patterns have highest precedence (prec(5)) to prevent conflicts with
        // typed_literal (prec(2)) or else_expression interpreting List<String>: as Type:value
        case_pattern: $ => choice(
            prec(5, $.type_expression),     // Type pattern: case List<String>:
            commaSep1($._expression),       // Value patterns: case 1, 2, 3:
            $.tuple_pattern,                // Tuple pattern: case (a, b):
        ),

        // Tuple pattern for switch: case (Lesser, _):
        tuple_pattern: $ => seq('(', commaSep1($.pattern_element), ')'),
        pattern_element: $ => choice($._expression, $.wildcard),
        wildcard: $ => '_',

        // Try statement can have resources: try (expr), try (Type var = expr), try (val var = expr)
        try_statement: $ => seq(
            'try',
            optional(seq('(', commaSep1($.try_resource), ')')),
            $.block,
            repeat($.catch_clause),
            optional(seq('finally', $.block)),
        ),

        // Try resource can be expression or variable declaration
        // prec(2) ensures val/var form is preferred over expression
        try_resource: $ => choice(
            prec(2, seq(optional(choice('val', 'var')), $.type_expression, $.identifier, '=', $._expression)),
            $._expression,
        ),

        catch_clause: $ => seq(
            'catch',
            '(',
            $.type_expression,
            $.identifier,
            ')',
            $.block,
        ),

        // Using statement: using (resource) { block }
        using_statement: $ => seq(
            'using',
            '(',
            commaSep1($.using_resource),
            ')',
            $.block,
        ),

        // Using resource can be:
        // - val/var id = expr
        // - val/var Type id = expr
        // - Type id = expr (explicit type, no val/var)
        using_resource: $ => seq(
            optional(choice('val', 'var')),
            optional($.type_expression),
            $.identifier,
            '=',
            $._expression,
        ),

        return_statement: $ => seq('return', optional(commaSep1($._expression)), ';'),
        break_statement: $ => seq('break', optional($.identifier), ';'),
        continue_statement: $ => seq('continue', optional($.identifier), ';'),
        throw_statement: $ => seq('throw', $._expression, ';'),

        // Assert can have: assert cond1, cond2, ... as message;
        // Where conditions can be expressions or conditional declarations
        // Conditions are optional: `assert as message;` is valid (always true, just emits message)
        // prec(2) ensures assert_statement is preferred over expression_statement with assert_expression
        assert_statement: $ => prec(2, seq(
            choice('assert', $.assert_variant),
            optional(seq(
                $.assert_condition,
                repeat(seq(',', $.assert_condition)),
            )),
            optional(seq('as', $._expression)),
            ';',
        )),
        assert_condition: $ => choice($._expression, $.conditional_declaration),
        assert_variant: $ => choice('assert:rnd', 'assert:arg', 'assert:bounds', 'assert:TODO', 'assert:once', 'assert:test', 'assert:debug'),

        // TODO statement: standalone TODO without semicolon (XTC compiler injects semicolon)
        // Allows: TODO, TODO(msg), TODO message text - all without trailing semicolon
        todo_statement: $ => prec(1, seq($.todo_expression, optional(';'))),

        expression_statement: $ => seq($._expression, ';'),

        // Expressions
        // Note: var/val are context keywords and can be used as variable names
        _expression: $ => choice(
            $.assignment_expression,
            $.else_expression,
            $.ternary_expression,
            $.binary_expression,
            $.unary_expression,
            $.postfix_expression,
            $.call_expression,
            $.member_expression,
            $.index_expression,
            $.new_expression,
            $.lambda_expression,
            $.switch_expression,
            $.throw_expression,
            $.assert_expression,
            $.todo_expression,
            $.tuple_expression,
            $.reference_expression,
            $.parenthesized_expression,
            $.this_expression,
            $.super_expression,
            // Block expression: { statements; return expr; } used as expression
            // Example: Type x = { ... return value; };
            $.statement_expression,
            $.identifier,
            // Context keywords as identifiers (variable names)
            alias('var', $.identifier),
            alias('val', $.identifier),
            $._literal,
        ),

        // Assignment expression - operators from model
        assignment_expression: $ => prec.right(1, seq($._expression, choice({{ASSIGNMENT_OPS}}), $._expression)),

        // Else expression: provides fallback for short-circuit expressions
        // Example: maxLength?.size() : 0  (if null, use 0)
        // Binds looser than ternary - parseElseExpression wraps parseTernaryExpression
        else_expression: $ => prec.right(0, seq($._expression, ':', $._expression)),

        ternary_expression: $ => prec.right(2, seq($._expression, '?', $._expression, ':', $._expression)),

        // Binary expression - generate from model operators grouped by precedence
        binary_expression: $ => choice(
{{BINARY_EXPRESSION_RULES}}
        ),

        // Unary operators - prefix operators from model (those that make sense as prefix)
        unary_expression: $ => prec.right({{MAX_PRECEDENCE_PLUS_1}}, seq(choice({{PREFIX_UNARY_OPS}}), $._expression)),

        // Postfix operators (including ? for short-circuit)
        // The ? postfix is used for short-circuit expressions: expr? means "short-circuit if null"
        postfix_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_1}}, seq($._expression, choice({{POSTFIX_OPS}}, '?'))),

        // Member access
        call_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_2}}, seq($._expression, optional($.type_arguments), $.arguments)),
        // Member expression supports:
        // - Regular: expr.name
        // - Reference: expr.&name (no-dereference property access)
        member_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_2}}, seq($._expression, choice({{MEMBER_ACCESS_OPS}}), optional('&'), $.identifier)),
        index_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_2}}, seq($._expression, '[', commaSep1($._expression), ']')),

        // Reference expression: &name (creates a reference to a property/variable)
        // Reference (no-dereference) expression: &identifier or &this:xxx
        reference_expression: $ => seq('&', choice($.identifier, $.this_expression)),

        // new Type(args), new Type[size], new Type[], new Type[size](initializer), or expr.new(args)
        // Also supports anonymous inner classes: new Type(args) { body }
        // Also supports annotated new: new @Annotation Type(args) (applies mixin to new instance)
        // prec.left on the array form ensures the optional initializer arguments are greedily consumed
        new_expression: $ => choice(
            seq('new', repeat($.annotation), $.type_expression, $.arguments, optional($.anonymous_inner_class_body)),
            prec.left(seq('new', repeat($.annotation), $.type_expression, '[', $._expression, ']', optional($.arguments))),
            seq('new', repeat($.annotation), $.type_expression, '[', ']'),  // empty array: new Type[]
            seq($._expression, '.', 'new', $.arguments),
        ),

        // Anonymous inner class body
        anonymous_inner_class_body: $ => seq('{', repeat($._class_member), '}'),

        // Throw expression: throw can be used as an expression in lambdas
        throw_expression: $ => seq('throw', $._expression),

        // Assert expression: assert can be used as an expression (e.g., in ?: or safe-call-else)
        // Used in patterns like: value?.method() : assert
        // Can include an optional message: `assert as $"error"` in expression context
        // prec.left ensures `as` binds to assert (not an outer context)
        assert_expression: $ => prec.left(seq('assert', optional(seq('as', $._expression)))),

        // TODO expression: placeholder for unimplemented code, throws UnsupportedOperation
        // Forms: TODO, TODO(), TODO(message), TODO message text
        // The inline text form (TODO message text) consumes rest of line
        // prec.left ensures parens are greedily consumed
        todo_expression: $ => prec.left(choice(
            seq('TODO', '(', optional($._expression), ')'),
            /TODO[ \t]+[^\n]+/,  // TODO with inline text message (rest of line)
            'TODO',
        )),

        // Lambda needs high precedence to resolve conflict: when seeing `identifier ->`,
        // prefer lambda over treating identifier as expression followed by -> binary op
        lambda_expression: $ => prec({{MAX_PRECEDENCE_PLUS_3}}, seq(
            choice($.identifier, $.parameters),
            '->',
            choice($._expression, $.block),
        )),
        parenthesized_expression: $ => seq('(', $._expression, ')'),

        // this expression: this, this:class, this:struct, this:module, this:service,
        // this:private, this:protected, this:public, this:target
        this_expression: $ => choice(
            'this',
            'this:class',
            'this:module',
            'this:struct',
            'this:service',
            'this:private',
            'this:protected',
            'this:public',
            'this:target',
        ),

        // super expression: super
        super_expression: $ => 'super',

        // Statement expression: a block used as an expression
        // Example: Type x = { var y = compute(); return y + 1; };
        // The block must contain statements and typically ends with a return
        statement_expression: $ => $.block,

        // Tuple expression: () or (a, b) or (a, b, c)
        // Empty tuple () is a valid value (e.g., as default parameter)
        // prec(1) to prefer empty_tuple over parenthesized_expression or tuple_type
        tuple_expression: $ => choice(
            prec(1, seq('(', ')')),  // Empty tuple
            seq('(', $._expression, ',', commaSep1($._expression), ')'),  // 2+ elements
        ),

        // Arguments can include expressions, type expressions (for .is(), .as(), etc.), and named arguments
        // Named arguments: name=value (e.g., entrySeparator='&')
        arguments: $ => seq('(', commaSep(choice($.named_argument, $._expression, $.type_expression)), ')'),
        named_argument: $ => seq($.identifier, '=', $._expression),

        // Literals
        _literal: $ => choice(
            $.integer_literal,
            $.float_literal,
            $.string_literal,
            $.template_string_literal,
            $.multiline_template_literal,
            $.multiline_literal,
            $.char_literal,
            $.boolean_literal,
            $.null_literal,
            $.list_literal,
            $.map_literal,
            $.typed_literal,
        ),

        // Integer literals support magnitude suffixes: K, M, G, T, P, E, Z, Y (case insensitive)
        // with optional B/I/IB suffix (e.g., 1K, 1Ki, 1KB, 1KiB, 1k, 1ki, 1kb, 1kib)
        integer_literal: $ => token(choice(
            /[0-9][0-9_]*([KkMmGgTtPpZzYy]([Ii]?[Bb]?)?)?/,
            // E is special - only treat as suffix if not followed by digit (else it's float exponent)
            /[0-9][0-9_]*[Ee]([Ii]?[Bb]?)/,
            /0[xX][0-9a-fA-F][0-9a-fA-F_]*/,
            /0[bB][01][01_]*/,
        )),

        float_literal: $ => /[0-9][0-9_]*\.[0-9][0-9_]*([eE][+-]?[0-9]+)?/,

        string_literal: $ => /"([^"\\]|\\.)*"/,
        template_string_literal: $ => /\$"([^"\\]|\\.)*"/,
        // Multiline template literal: $|content on first line
        //                              | continuation line
        // The pattern captures $| followed by content, with optional continuation lines starting with |
        multiline_template_literal: $ => token(/\$\|[^\n]*(\\?\n[ \t]*\|[^\n]*)*/),
        // Multiline plain literal: \|content on first line
        //                           | continuation line
        multiline_literal: $ => token(/\\\|[^\n]*(\\?\n[ \t]*\|[^\n]*)*/),
        char_literal: $ => /'([^'\\]|\\.)'/,

{{BOOLEAN_LITERAL_RULE}}
{{NULL_LITERAL_RULE}}

        list_literal: $ => seq('[', commaSep($._expression), ']'),
        map_literal: $ => seq('[', commaSep($.map_entry), ']'),
        map_entry: $ => seq($._expression, '=', $._expression),

        // Typed literal: Type:value where value is a literal
        // Examples: Duration:0S, Int:42, Map:[], List:[1,2,3], Date:2024-01-26
        // Use higher precedence to prefer typed_literal interpretation
        typed_literal: $ => prec(2, seq($.type_expression, ':', choice(
            $.list_literal,
            $.map_literal,
            $.duration_literal,
            $.integer_literal,
            $.float_literal,
            $.string_literal,
            $.char_literal,
            $.boolean_literal,
        ))),

        // Duration literal: ISO-8601 format (P prefix optional in XTC shorthand)
        // Examples: PT1H30M (1 hour 30 min), P1D (1 day), 30S (30 seconds), PT0S (0 seconds)
        duration_literal: $ => /P?T?[0-9]+[YMDHS]([0-9]+[YMDHS])*/i,

        // Identifiers and names
        // type_name can be a simple identifier or a qualified name (e.g., ecstasy.io.Channel)
        identifier: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,
        // Context keywords (val, var, etc.) can be used as identifiers in some contexts
        // Use alias to create visible identifier nodes when keywords are used as names
        _identifier_or_context_keyword: $ => choice($.identifier, alias('val', $.identifier), alias('var', $.identifier)),
        type_name: $ => choice($.identifier, $.qualified_type_name),
        qualified_type_name: $ => prec.left(sep1($.identifier, '.')),
        qualified_name: $ => sep1($.identifier, '.'),

        // Annotations - can have qualified names (e.g., @foo.bar.Baz)
        // Two forms: with arguments @Name(args) or without @Name
        // The form with arguments requires '(' immediately after name (no whitespace/newline)
        annotation: $ => choice(
            seq('@', $.qualified_name, token.immediate('('), commaSep(choice($._expression, $.type_expression)), ')'),
            seq('@', $.qualified_name),
        ),

{{VISIBILITY_MODIFIER_RULE}}

        // Comments
        // Note: block_comment explicitly excludes doc comments (/**) to prevent conflicts
        // when block_comment is used as an extra. Doc comments start with /** followed by
        // content, while block_comment matches /* NOT followed by another *.
        comment: $ => choice(
            $.line_comment,
            $.block_comment,
            $.doc_comment,
        ),

        line_comment: $ => token(seq('//', /.*/)),
        // Block comment: /* followed by (non-* OR */) then content until */
        // This regex ensures /** is NOT matched as a block comment
        block_comment: $ => token(seq('/*', choice(token.immediate(/[^*]/), token.immediate('/')), /([^*]|\*[^/])*\*?/, '/')),
        doc_comment: $ => token(seq('/**', /([^*]|\*[^/])*\*?/, '/')),
    },
});

function sep1(rule, separator) {
    return seq(rule, repeat(seq(separator, rule)));
}

function commaSep(rule) {
    return optional(commaSep1(rule));
}

function commaSep1(rule) {
    return seq(rule, repeat(seq(',', rule)));
}
