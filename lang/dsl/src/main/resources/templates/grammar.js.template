/**
 * Tree-sitter grammar for {{LANGUAGE_NAME}}
 * Generated from XTC language model
 */

module.exports = grammar({
  name: 'xtc',

  // Note: doc_comment is NOT in extras - it's an explicit optional prefix to declarations.
  // This prevents tree-sitter's GLR parser from misidentifying keywords after doc comments.
  // Only whitespace and non-doc comments are extras (can appear anywhere).
  extras: $ => [
    /\s/,
    $.line_comment,
    $.block_comment,
  ],

  externals: $ => [],

  // Conflicts that need explicit declaration:
  // 1. unary vs binary vs call: `+expr<T>()` - is `<` comparison or type arg?
  // 2. binary vs call: `a..b<T>()` - `<` could be comparison or type arg
  // 3. list vs map literal: `[]` could be empty list or empty map
  // 4. array_type vs conditional_type: `conditional T[]` - is [] on conditional or on T?
  // 5. _non_bi_type conflicts with union/intersection types
  // 6. type_expression vs tuple_type in contexts like typedef (Type1 | Type2) as Name
  // The parser resolves these by preferring the higher precedence rule
  conflicts: $ => [
    [$.binary_expression, $.unary_expression, $.call_expression],
    [$.binary_expression, $.call_expression],
    [$.list_literal, $.map_literal],
    [$.array_type, $.conditional_type],
    [$.nullable_type, $.conditional_type],
    [$._expression, $.type_name],
    [$.member_expression, $.qualified_type_name],
    [$.type_name, $.qualified_type_name],
    [$.member_type, $.qualified_type_name],
    [$.generic_type, $.member_type],
    [$._expression, $.qualified_type_name],
    [$._expression, $.type_name, $.qualified_type_name],
    [$.union_type, $._non_bi_type],
    [$.intersection_type, $._non_bi_type],
    [$.difference_type, $._non_bi_type],
    [$.type_expression, $.tuple_type],
    [$.parenthesized_type, $.tuple_type],
    [$.immutable_type, $.array_type],
    [$.immutable_type, $.nullable_type],
    [$.non_null_type, $.conditional_type],
    [$.immutable_type, $.non_null_type],
    [$.non_null_type, $.postfix_expression],
    [$.class_declaration, $.keyword_type],
    [$.service_declaration, $.keyword_type],
    [$.const_declaration, $.keyword_type],
    [$.enum_declaration, $.keyword_type],
    [$.conditional_declaration, $._expression],
    [$.switch_statement, $.switch_expression],
    [$.case_pattern, $._expression],
    [$.pattern_element, $._expression],
    [$.tuple_pattern, $.parenthesized_expression],
    [$.pattern_element, $.parenthesized_expression],
    [$.new_expression, $.member_expression],
    [$.unary_expression, $.member_expression, $.new_expression],
    [$.assignment_expression, $.member_expression, $.new_expression],
    [$.binary_expression, $.member_expression, $.new_expression],
    [$.binary_expression, $.unary_expression, $.member_expression, $.new_expression],
    [$.ternary_expression, $.member_expression, $.new_expression],
    [$.expression_case_clause, $.case_clause],
    [$.expression_case_clause, $.expression_statement],
    [$.assert_condition, $._expression],
    [$.pattern_element, $.tuple_expression],
    [$.throw_expression, $.binary_expression],
    [$.throw_statement, $.throw_expression],
    [$.assert_statement, $.assert_expression],
    [$._expression, $.type_expression],
    [$.variable_declaration, $.expression_statement],
    [$.variable_declaration, $._expression],
    [$.labeled_statement, $.variable_declaration],
    [$.labeled_statement, $.type_name],
    [$.labeled_statement, $.qualified_type_name],
    [$.tuple_assignment, $.expression_statement],
    [$.tuple_assignment_element, $._expression],
    [$.tuple_assignment_element, $.tuple_expression],
    [$.tuple_assignment_element, $.parameter],
    [$.for_tuple_destructure, $.tuple_expression],
    [$.for_tuple_destructure, $.parameters],
    [$.for_tuple_destructure, $.parameter],
    [$.conditional_tuple_pattern, $.for_tuple_destructure],
    [$.conditional_tuple_pattern, $.tuple_expression],
    [$.conditional_tuple_pattern, $.parameters],
    [$.conditional_tuple_pattern, $.parameter],
    [$.if_condition, $._expression],
    [$.type_expression, $.array_type],
    [$.function_type_parameters, $.tuple_type],
    [$.tuple_type_element, $.parameter],
    [$.tuple_type_element, $.type_expression],
    [$.conditional_type, $.function_type],
    [$.incorporates_clause, $.conditional_type],
    [$._non_bi_type, $.generic_type],
    [$.named_argument, $._expression],
    [$.switch_variable_declaration, $._expression],
  ],

  word: $ => $.identifier,

  rules: {
    // Source file
    source_file: $ => repeat($._definition),

    // Definitions
    _definition: $ => choice(
      $.module_declaration,
      $.package_declaration,
      $.import_statement,
      $.class_declaration,
      $.interface_declaration,
      $.mixin_declaration,
      $.service_declaration,
      $.const_declaration,
      $.enum_declaration,
      $.typedef_declaration,
    ),

    // Module declaration
    // Note: doc_comment is optional prefix, not in extras, to avoid keyword recognition issues
    module_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      'module',
      $.qualified_name,
      optional($.module_body),
    ),

    module_body: $ => seq('{', repeat($._definition), '}'),

    // Package declaration
    // Note: Package must end with either a body { } or semicolon ;
    // This resolves the ambiguity between inline import_spec and standalone import_statement
    // Examples: "package foo;" or "package foo { }" or "package foo import bar.baz;"
    package_declaration: $ => seq(
      repeat($.annotation),
      'package',
      $.identifier,
      optional($.import_spec),
      choice($.package_body, ';'),
    ),

    package_body: $ => seq('{', repeat($._definition), '}'),

    // Import
    import_statement: $ => seq(
      'import',
      $.qualified_name,
      optional(seq('as', $.identifier)),
      ';',
    ),

    import_spec: $ => seq('import', $.qualified_name),

    // Class declaration
    // Note: XTC allows multiple implements clauses, e.g.:
    //   class Foo implements A implements B implements C
    // Also allows annotations to appear after static: protected static @Abstract class
    // The extends/implements/incorporates clauses can appear in any order
    class_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      optional(seq('static', repeat($.annotation))),
      optional('abstract'),
      'class',
      $.type_name,
      optional($.type_parameters),
      optional($.constructor_parameters),
      repeat(choice($.extends_clause_with_args, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
      $.class_body,
    ),

    // Similar declarations
    interface_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      optional('static'),
      'interface',
      $.type_name,
      optional($.type_parameters),
      repeat($.extends_clause),
      $.class_body,
    ),

    mixin_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      optional('static'),
      'mixin',
      $.type_name,
      optional($.type_parameters),
      optional($.constructor_parameters),
      repeat(choice($.into_clause, $.extends_clause, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
      $.class_body,
    ),

    service_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      'service',
      $.type_name,
      optional($.type_parameters),
      optional($.constructor_parameters),
      repeat(choice($.extends_clause, $.implements_clause, $.incorporates_clause, $.delegates_clause)),
      $.class_body,
    ),

    // Const declaration allows annotations to appear after static: static @Abstract const
    const_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      optional(seq('static', repeat($.annotation))),
      'const',
      $.type_name,
      optional($.type_parameters),
      optional($.constructor_parameters),
      repeat(choice($.extends_clause_with_args, $.implements_clause, $.incorporates_clause, $.delegates_clause, $.default_clause)),
      choice($.class_body, ';'),
    ),

    enum_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      'enum',
      $.type_name,
      optional($.type_parameters),
      optional($.constructor_parameters),
      optional($.enum_default_clause),
      repeat($.implements_clause),
      repeat($.incorporates_clause),
      $.enum_body,
    ),

    constructor_parameters: $ => $.parameters,
    enum_default_clause: $ => seq('default', $.arguments),
    // Default clause for const types: default(value)
    default_clause: $ => seq('default', $.arguments),

    // Typedef: typedef Type as Name;
    typedef_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      'typedef',
      $.type_expression,
      'as',
      $.identifier,
      ';',
    ),

    // Class body
    class_body: $ => seq('{', repeat($._class_member), '}'),

    enum_body: $ => seq(
      '{',
      optional($.enum_values),
      optional(seq(';', repeat($._class_member))),
      '}',
    ),

    enum_values: $ => seq($.enum_value, repeat(seq(',', $.enum_value)), optional(',')),

    // Enum values can have doc comments, arguments, and/or a body with methods
    enum_value: $ => seq(
      optional($.doc_comment),
      $.identifier,
      optional($.arguments),
      optional($.enum_value_body),
    ),

    enum_value_body: $ => seq('{', repeat($._class_member), '}'),

    // Class members
    _class_member: $ => choice(
      $.property_declaration,
      $.method_declaration,
      $.property_getter_declaration,
      $.constructor_declaration,
      $.assert_block,
      $.class_declaration,
      $.interface_declaration,
      $.const_declaration,
      $.enum_declaration,
      $.typedef_declaration,
      $.mixin_declaration,
      $.service_declaration,
    ),

    // Property declaration supports annotations before and/or after visibility
    // e.g., @Override public Int x; OR public/protected @Unassigned Key key;
    // Properties can have: simple value (;), initializer (= expr;), or a body with accessors ({ ... })
    property_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional(seq($.visibility_modifier, repeat($.annotation))),
      optional(seq('static', repeat($.annotation))),
      $.type_expression,
      $.identifier,
      choice(
        seq(optional(seq('=', $._expression)), ';'),
        $.property_body,
      ),
    ),

    // Property body: { getter/setter methods, nested classes, etc. }
    // This is similar to a class body but for properties
    property_body: $ => seq('{', repeat($._class_member), '}'),

    method_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      optional('static'),
      optional('abstract'),
      optional($.type_parameters),
      $.type_expression,
      $.identifier,
      optional($.type_parameters),
      $.parameters,
      choice($.block, seq('=', $._expression, ';'), ';'),
    ),

    // Property accessor syntax: `Type propName.get() { ... }` or `Type propName.calc() = expr;`
    // Supports any accessor method name (get, set, calc, add, etc.)
    property_getter_declaration: $ => seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      $.type_expression,
      $.identifier,
      '.',
      $.identifier,
      $.parameters,
      choice($.block, seq('=', $._expression, ';'), ';'),
    ),

    // Constructor can have optional finally block: construct(...) { } finally { }
    // prec.right prefers to attach 'finally' to current constructor rather than new declaration
    // Constructor can also be just a signature (ending with ;) in interfaces
    constructor_declaration: $ => prec.right(seq(
      optional($.doc_comment),
      repeat($.annotation),
      optional($.visibility_modifier),
      choice('construct', 'finally'),
      $.parameters,
      choice(
        seq($.block, optional(seq('finally', $.block))),
        ';',
      ),
    )),

    // Assert block (in const classes): `assert() { ... }`
    assert_block: $ => seq(
      'assert',
      $.parameters,
      $.block,
    ),

    // Clauses
    extends_clause: $ => seq('extends', $.type_expression),
    extends_clause_with_args: $ => seq('extends', $.type_expression, optional($.arguments)),
    implements_clause: $ => seq('implements', commaSep1($.type_expression)),
    // Incorporates can be conditional: incorporates conditional Mixin<Type extends Constraint>
    // Uses $._non_bi_type after 'conditional' to avoid conflict with conditional_type in type_expression
    incorporates_clause: $ => choice(
      seq('incorporates', 'conditional', $._non_bi_type, optional($.arguments)),
      seq('incorporates', $.type_expression, optional($.arguments)),
    ),
    // Delegates clause: delegates Type(expr)
    delegates_clause: $ => seq('delegates', $.type_expression, '(', $._expression, ')'),
    into_clause: $ => seq('into', $.type_expression),

    // Type parameters
    type_parameters: $ => seq('<', commaSep1($.type_parameter), '>'),
    type_parameter: $ => seq($.identifier, optional(seq('extends', $.type_expression))),

    // Parameters (with optional trailing comma)
    parameters: $ => seq('(', commaSep($.parameter), optional(','), ')'),
    parameter: $ => seq(
      $.type_expression,
      $.identifier,
      optional(seq('=', $._expression)),
    ),

    // Type expressions
    // Note: array_type uses prec.left to greedily consume [] after types
    // Includes 'void' as a special primitive type (lowercase)
    // Union (|), intersection (+), and difference (-) types have lowest precedence
    type_expression: $ => choice(
      $.union_type,
      $.intersection_type,
      $.difference_type,
      $._non_bi_type,
    ),

    // Binary type operations - union binds looser than intersection/difference
    union_type: $ => prec.left(1, seq($._non_bi_type, '|', $.type_expression)),
    intersection_type: $ => prec.left(2, seq($._non_bi_type, '+', $.type_expression)),
    difference_type: $ => prec.left(2, seq($._non_bi_type, '-', $.type_expression)),

    // Non-binary type expressions (no | or + or -)
    _non_bi_type: $ => choice(
      $.type_name,
      $.primitive_type,
      $.generic_type,
      $.member_type,
      $.array_type,
      $.nullable_type,
      $.non_null_type,
      $.conditional_type,
      $.function_type,
      $.tuple_type,
      $.immutable_type,
      $.parenthesized_type,
      $.keyword_type,
    ),

    primitive_type: $ => 'void',
    keyword_type: $ => choice('service', 'const', 'enum', 'module', 'package', 'class'),
    // immutable can be standalone or with a type. prec.right makes it greedy.
    immutable_type: $ => prec.right(seq('immutable', optional($._non_bi_type))),
    parenthesized_type: $ => seq('(', $.type_expression, ')'),

    // Generic type: Map<Key> or Map!<Key> (non-null generic)
    // The ! must come before type arguments: Name!<Args>, not Name<Args>!
    generic_type: $ => seq($.type_name, optional(token.immediate('!')), $.type_arguments),
    // Member type access: Type<Key>.MemberType or Package.TypeName
    // Used in typedef Type<Key>.Orderer as Orderer
    member_type: $ => prec.left(seq(choice($.generic_type, $.type_name), '.', $.identifier)),
    // Type arguments can include constraints: <Key, Value extends Shareable>
    type_arguments: $ => seq('<', commaSep1($.type_argument), '>'),
    type_argument: $ => seq($.type_expression, optional(seq('extends', $.type_expression))),
    array_type: $ => prec.left(seq($._non_bi_type, '[', ']')),
    nullable_type: $ => prec.left(seq($._non_bi_type, '?')),
    // Non-null type modifier (no auto-narrowing): Type!
    non_null_type: $ => prec.left(seq($._non_bi_type, token.immediate('!'))),
    conditional_type: $ => seq('conditional', $._non_bi_type),
    // Function type: function ReturnType(ParamTypes) - parameters are just types, no names
    function_type: $ => seq('function', optional('conditional'), $._non_bi_type, $.function_type_parameters),
    function_type_parameters: $ => seq('(', commaSep($.type_expression), ')'),
    // Tuple type can be unnamed (Type1, Type2) or named (Type1 name1, Type2 name2)
    tuple_type: $ => seq('(', commaSep($.tuple_type_element), ')'),
    tuple_type_element: $ => seq($._non_bi_type, optional($.identifier)),

    // Statements
    block: $ => seq('{', repeat($._statement), '}'),

    _statement: $ => choice(
      $.block,
      $.labeled_statement,
      $.variable_declaration,
      $.tuple_assignment,
      $.if_statement,
      $.for_statement,
      $.while_statement,
      $.do_statement,
      $.switch_statement,
      $.try_statement,
      $.using_statement,
      $.return_statement,
      $.break_statement,
      $.continue_statement,
      $.assert_statement,
      $.throw_statement,
      $.construct_delegation,
      $.expression_statement,
      // Local imports (inside method bodies)
      $.import_statement,
      // Local type declarations (inner classes, interfaces, etc.)
      $.class_declaration,
      $.interface_declaration,
      $.const_declaration,
      $.enum_declaration,
      $.mixin_declaration,
      // Local function declarations (functions defined inside method bodies)
      $.local_function_declaration,
    ),

    // Local function declaration: visibility, static, return type, name, params, body
    // Supports: private static (String, String) decode(Entry entry) { ... }
    local_function_declaration: $ => seq(
      repeat($.annotation),
      optional($.visibility_modifier),
      optional('static'),
      optional($.type_parameters),
      $.type_expression,
      $.identifier,
      $.parameters,
      choice($.block, seq('=', $._expression, ';')),
    ),

    // Labeled statement: Label: for/while/do/switch/if/block
    // Higher precedence to prefer label interpretation over type_name
    labeled_statement: $ => prec(1, seq(
      $.identifier,
      ':',
      choice($.for_statement, $.while_statement, $.do_statement, $.switch_statement, $.if_statement, $.block),
    )),

    // Constructor delegation: construct ConstructorName(args);
    construct_delegation: $ => seq(
      'construct',
      $.type_name,
      $.arguments,
      ';',
    ),

    // Tuple assignment: (Type1 x, Type2 y) = expr; or (x, this.y) = expr;
    tuple_assignment: $ => seq(
      '(',
      $.tuple_assignment_element,
      repeat1(seq(',', $.tuple_assignment_element)),
      ')',
      '=',
      $._expression,
      ';',
    ),

    // Element in tuple assignment: can be typed (Type x) or untyped (x, this.y)
    tuple_assignment_element: $ => choice(
      seq($.type_expression, $.identifier),
      $._expression,
    ),

    // Statement implementations
    // Variable declarations can be:
    // - val x = expr;  or  var x = expr;  (with optional type)
    // - Type x = expr;  (explicit type without val/var)
    // - @Annotation Type x = expr;  (with annotations)
    // - private Type x = expr;  (with visibility modifier for local captures)
    // - static Type x = expr;  (local static property)
    variable_declaration: $ => choice(
      // val/var form: val x = expr or var Type x = expr
      seq(
        repeat($.annotation),
        optional($.visibility_modifier),
        choice('val', 'var'),
        optional($.type_expression),
        $.identifier,
        optional(seq(choice('=', ':='), $._expression)),
        ';',
      ),
      // Typed form without val/var: @Annotation private static Type x = expr;
      seq(
        repeat($.annotation),
        optional($.visibility_modifier),
        optional('static'),
        $.type_expression,
        $.identifier,
        optional(seq(choice('=', ':='), $._expression)),
        ';',
      ),
    ),

    // Conditional declaration: val x := expr or Type x := expr (used in if/while conditions)
    // Also supports: Type x ?= expr (not-null assignment)
    // Also supports tuple destructuring: (Type1 x, Type2 y) := expr
    conditional_declaration: $ => seq(
      choice(
        seq(choice('val', 'var'), optional($.type_expression), $.identifier),
        seq($.type_expression, $.identifier),
        $.conditional_tuple_pattern,
      ),
      choice(':=', '?='),
      $._expression,
    ),

    // Tuple pattern for conditional declaration: (Type1 x, Type2 y)
    conditional_tuple_pattern: $ => seq(
      '(',
      $.type_expression, $.identifier,
      repeat1(seq(',', $.type_expression, $.identifier)),
      ')',
    ),

    // Dangling else: `if (a) if (b) x else y` - else binds to nearest if (right associativity)
    // Supports conditional declaration: if (val x := expr) or if (Type x := expr)
    // Also supports multiple conditions: if (cond1, cond2, ...) where each can be expr or decl
    if_statement: $ => prec.right(seq(
      'if',
      '(',
      $.if_condition,
      repeat(seq(',', $.if_condition)),
      ')',
      $._statement,
      optional(seq('else', $._statement)),
    )),

    // A condition in an if/while statement: expression or conditional declaration
    if_condition: $ => choice($._expression, $.conditional_declaration),

    for_statement: $ => seq(
      'for',
      '(',
      choice(
        // for (val name : iterable) or for (var name : iterable) - prefer val/var keywords first
        prec(2, seq('val', $._identifier_or_context_keyword, ':', $._expression)),
        prec(2, seq('var', $._identifier_or_context_keyword, ':', $._expression)),
        // for (Type name : iterable)
        prec(1, seq($.type_expression, $._identifier_or_context_keyword, ':', $._expression)),
        seq($.for_tuple_destructure, ':', $._expression),
        seq(optional($._expression), ';', optional($._expression), ';', optional($._expression)),
      ),
      ')',
      $._statement,
    ),

    // Tuple destructuring pattern for for-each: ((Type1 name1, Type2 name2))
    for_tuple_destructure: $ => seq(
      '(',
      $.type_expression, $.identifier,
      repeat1(seq(',', $.type_expression, $.identifier)),
      ')',
    ),

    // Supports conditional declaration: while (Element x := expr)
    // Supports multiple conditions: while (cond1, cond2)
    while_statement: $ => seq('while', '(', $.if_condition, repeat(seq(',', $.if_condition)), ')', $._statement),
    do_statement: $ => seq('do', $._statement, 'while', '(', $._expression, ')', ';'),

    // Switch statement (traditional form with statements)
    // Can have inline variable declarations: switch (Type name = expr)
    switch_statement: $ => seq(
      'switch',
      '(',
      commaSep1(choice($.switch_variable_declaration, $._expression)),
      ')',
      '{',
      repeat($.case_clause),
      '}',
    ),

    // Switch expression (returns a value): switch (x) { case A: value; }
    // Can have inline variable declarations: switch (Type name = expr)
    switch_expression: $ => seq(
      'switch',
      '(',
      commaSep1(choice($.switch_variable_declaration, $._expression)),
      ')',
      '{',
      repeat($.expression_case_clause),
      '}',
    ),

    // Variable declaration inside switch expression: Type name = expr
    switch_variable_declaration: $ => seq($.type_expression, $.identifier, '=', $._expression),

    // Case clause for switch statements (can contain statements)
    case_clause: $ => seq(
      choice(seq('case', $.case_pattern), 'default'),
      ':',
      repeat($._statement),
    ),

    // Expression case clause for switch expressions (returns value with semicolon)
    expression_case_clause: $ => seq(
      choice(seq('case', $.case_pattern), 'default'),
      ':',
      $._expression,
      ';',
    ),

    // Case pattern: single expression, comma-separated expressions, or tuple pattern
    // Supports: case 'P', 'p':  (multiple values in one case)
    case_pattern: $ => choice(
      commaSep1($._expression),
      $.tuple_pattern,
    ),

    // Tuple pattern for switch: case (Lesser, _):
    tuple_pattern: $ => seq('(', commaSep1($.pattern_element), ')'),
    pattern_element: $ => choice($._expression, $.wildcard),
    wildcard: $ => '_',

    try_statement: $ => seq(
      'try',
      optional(seq('(', commaSep1($._expression), ')')),
      $.block,
      repeat($.catch_clause),
      optional(seq('finally', $.block)),
    ),

    catch_clause: $ => seq(
      'catch',
      '(',
      $.type_expression,
      $.identifier,
      ')',
      $.block,
    ),

    // Using statement: using (resource) { block }
    using_statement: $ => seq(
      'using',
      '(',
      commaSep1($.using_resource),
      ')',
      $.block,
    ),

    using_resource: $ => seq(
      choice('val', 'var'),
      optional($.type_expression),
      $.identifier,
      '=',
      $._expression,
    ),

    return_statement: $ => seq('return', optional(commaSep1($._expression)), ';'),
    break_statement: $ => seq('break', optional($.identifier), ';'),
    continue_statement: $ => seq('continue', optional($.identifier), ';'),
    throw_statement: $ => seq('throw', $._expression, ';'),

    // Assert can have: assert cond1, cond2, ... as message;
    // Where conditions can be expressions or conditional declarations
    assert_statement: $ => seq(
      choice('assert', $.assert_variant),
      $.assert_condition,
      repeat(seq(',', $.assert_condition)),
      optional(seq('as', $._expression)),
      ';',
    ),
    assert_condition: $ => choice($._expression, $.conditional_declaration),
    assert_variant: $ => choice('assert:rnd', 'assert:arg', 'assert:bounds', 'assert:TODO', 'assert:once', 'assert:test', 'assert:debug'),
    expression_statement: $ => seq($._expression, ';'),

    // Expressions
    // Note: var/val are context keywords and can be used as variable names
    _expression: $ => choice(
      $.assignment_expression,
      $.ternary_expression,
      $.binary_expression,
      $.unary_expression,
      $.postfix_expression,
      $.call_expression,
      $.member_expression,
      $.index_expression,
      $.new_expression,
      $.lambda_expression,
      $.switch_expression,
      $.throw_expression,
      $.assert_expression,
      $.tuple_expression,
      $.reference_expression,
      $.parenthesized_expression,
      $.this_expression,
      $.super_expression,
      $.identifier,
      // Context keywords as identifiers (variable names)
      alias('var', $.identifier),
      alias('val', $.identifier),
      $._literal,
    ),

    // Assignment expression - operators from model
    assignment_expression: $ => prec.right(1, seq($._expression, choice({{ASSIGNMENT_OPS}}), $._expression)),
    ternary_expression: $ => prec.right(2, seq($._expression, '?', $._expression, ':', $._expression)),

    // Binary expression - generate from model operators grouped by precedence
    binary_expression: $ => choice(
{{BINARY_EXPRESSION_RULES}}
    ),

    // Unary operators - prefix operators from model (those that make sense as prefix)
    unary_expression: $ => prec.right({{MAX_PRECEDENCE_PLUS_1}}, seq(choice({{PREFIX_UNARY_OPS}}), $._expression)),

    // Postfix operators
    postfix_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_1}}, seq($._expression, choice({{POSTFIX_OPS}}))),

    // Member access
    call_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_2}}, seq($._expression, optional($.type_arguments), $.arguments)),
    // Member expression supports:
    // - Regular: expr.name
    // - Reference: expr.&name (no-dereference property access)
    member_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_2}}, seq($._expression, choice({{MEMBER_ACCESS_OPS}}), optional('&'), $.identifier)),
    index_expression: $ => prec.left({{MAX_PRECEDENCE_PLUS_2}}, seq($._expression, '[', commaSep1($._expression), ']')),

    // Reference expression: &name (creates a reference to a property/variable)
    reference_expression: $ => seq('&', $.identifier),

    // new Type(args), new Type[size], new Type[], new Type[size](initializer), or expr.new(args)
    // Also supports anonymous inner classes: new Type(args) { body }
    // prec.left on the array form ensures the optional initializer arguments are greedily consumed
    new_expression: $ => choice(
      seq('new', $.type_expression, $.arguments, optional($.anonymous_inner_class_body)),
      prec.left(seq('new', $.type_expression, '[', $._expression, ']', optional($.arguments))),
      seq('new', $.type_expression, '[', ']'),  // empty array: new Type[]
      seq($._expression, '.', 'new', $.arguments),
    ),

    // Anonymous inner class body
    anonymous_inner_class_body: $ => seq('{', repeat($._class_member), '}'),

    // Throw expression: throw can be used as an expression in lambdas
    throw_expression: $ => seq('throw', $._expression),

    // Assert expression: assert can be used as an expression (e.g., in ?: or safe-call-else)
    // Used in patterns like: value?.method() : assert
    assert_expression: $ => 'assert',

    // Lambda needs high precedence to resolve conflict: when seeing `identifier ->`,
    // prefer lambda over treating identifier as expression followed by -> binary op
    lambda_expression: $ => prec({{MAX_PRECEDENCE_PLUS_3}}, seq(
      choice($.identifier, $.parameters),
      '->',
      choice($._expression, $.block),
    )),
    parenthesized_expression: $ => seq('(', $._expression, ')'),

    // this expression: this, this:class, this:struct, this:module, this:service,
    // this:private, this:protected, this:public, this:target
    this_expression: $ => choice(
      'this',
      'this:class',
      'this:module',
      'this:struct',
      'this:service',
      'this:private',
      'this:protected',
      'this:public',
      'this:target',
    ),

    // super expression: super
    super_expression: $ => 'super',

    // Tuple expression: (a, b) or (a, b, c) - at least 2 elements
    tuple_expression: $ => seq('(', $._expression, ',', commaSep1($._expression), ')'),

    // Arguments can include expressions, type expressions (for .is(), .as(), etc.), and named arguments
    // Named arguments: name=value (e.g., entrySeparator='&')
    arguments: $ => seq('(', commaSep(choice($.named_argument, $._expression, $.type_expression)), ')'),
    named_argument: $ => seq($.identifier, '=', $._expression),

    // Literals
    _literal: $ => choice(
      $.integer_literal,
      $.float_literal,
      $.string_literal,
      $.template_string_literal,
      $.multiline_template_literal,
      $.multiline_literal,
      $.char_literal,
      $.boolean_literal,
      $.null_literal,
      $.list_literal,
      $.map_literal,
      $.typed_literal,
    ),

    // Integer literals support magnitude suffixes: K, M, G, T, P, E, Z, Y (case insensitive)
    // with optional B/I/IB suffix (e.g., 1K, 1Ki, 1KB, 1KiB, 1k, 1ki, 1kb, 1kib)
    integer_literal: $ => token(choice(
      /[0-9][0-9_]*([KkMmGgTtPpZzYy]([Ii]?[Bb]?)?)?/,
      // E is special - only treat as suffix if not followed by digit (else it's float exponent)
      /[0-9][0-9_]*[Ee]([Ii]?[Bb]?)/,
      /0[xX][0-9a-fA-F][0-9a-fA-F_]*/,
      /0[bB][01][01_]*/,
    )),

    float_literal: $ => /[0-9][0-9_]*\.[0-9][0-9_]*([eE][+-]?[0-9]+)?/,

    string_literal: $ => /"([^"\\]|\\.)*"/,
    template_string_literal: $ => /\$"([^"\\]|\\.)*"/,
    // Multiline template literal: $|content on first line
    //                              | continuation line
    // The pattern captures $| followed by content, with optional continuation lines starting with |
    multiline_template_literal: $ => token(/\$\|[^\n]*(\\?\n[ \t]*\|[^\n]*)*/),
    // Multiline plain literal: \|content on first line
    //                           | continuation line
    multiline_literal: $ => token(/\\\|[^\n]*(\\?\n[ \t]*\|[^\n]*)*/),
    char_literal: $ => /'([^'\\]|\\.)'/,

{{BOOLEAN_LITERAL_RULE}}
{{NULL_LITERAL_RULE}}

    list_literal: $ => seq('[', commaSep($._expression), ']'),
    map_literal: $ => seq('[', commaSep($.map_entry), ']'),
    map_entry: $ => seq($._expression, '=', $._expression),

    // Typed literal: Type:[] or Type:[values...]
    typed_literal: $ => seq($.type_expression, ':', choice($.list_literal, $.map_literal)),

    // Identifiers and names
    // type_name can be a simple identifier or a qualified name (e.g., ecstasy.io.Channel)
    identifier: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,
    // Context keywords (val, var, etc.) can be used as identifiers in some contexts
    // Use alias to create visible identifier nodes when keywords are used as names
    _identifier_or_context_keyword: $ => choice($.identifier, alias('val', $.identifier), alias('var', $.identifier)),
    type_name: $ => choice($.identifier, $.qualified_type_name),
    qualified_type_name: $ => prec.left(sep1($.identifier, '.')),
    qualified_name: $ => sep1($.identifier, '.'),

    // Annotations - can have qualified names (e.g., @foo.bar.Baz)
    // Two forms: with arguments @Name(args) or without @Name
    // The form with arguments requires '(' immediately after name (no whitespace/newline)
    annotation: $ => choice(
      seq('@', $.qualified_name, token.immediate('('), commaSep(choice($._expression, $.type_expression)), ')'),
      seq('@', $.qualified_name),
    ),

{{VISIBILITY_MODIFIER_RULE}}

    // Comments
    // Note: block_comment explicitly excludes doc comments (/**) to prevent conflicts
    // when block_comment is used as an extra. Doc comments start with /** followed by
    // content, while block_comment matches /* NOT followed by another *.
    comment: $ => choice(
      $.line_comment,
      $.block_comment,
      $.doc_comment,
    ),

    line_comment: $ => token(seq('//', /.*/)),
    // Block comment: /* followed by (non-* OR */) then content until */
    // This regex ensures /** is NOT matched as a block comment
    block_comment: $ => token(seq('/*', choice(token.immediate(/[^*]/), token.immediate('/')), /([^*]|\*[^/])*\*?/, '/')),
    doc_comment: $ => token(seq('/**', /([^*]|\*[^/])*\*?/, '/')),
  },
});

function sep1(rule, separator) {
  return seq(rule, repeat(seq(separator, rule)));
}

function commaSep(rule) {
  return optional(commaSep1(rule));
}

function commaSep1(rule) {
  return seq(rule, repeat(seq(',', rule)));
}
