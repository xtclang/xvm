LEXER-01  = Unexpected End-Of-File (SUB character).
LEXER-02  = Expected a comment-ending "star slash" but never found one.
LEXER-03  = Invalid character: "{0}".
LEXER-04  = Illegal number: "{0}".
LEXER-05  = An illegal character literal, missing closing quote: "{0}".
LEXER-06  = An illegally escaped character literal: "{0}".
LEXER-07  = An illegal character literal missing the character: "{0}".
LEXER-08  = An illegally terminated string literal: "{0}".
LEXER-09  = An illegally escaped string literal: "{0}".
LEXER-10  = Illegal hex value: "{0}".
LEXER-11  = Expected "{0}"; found "{1}".
LEXER-12  = "{0}" digits were required; only "{1}" digits were found.
LEXER-13  = Invalid ISO-8601 date "{0}"; date must be in the format "YYYY-MM-DD" with valid values for each.
LEXER-14  = Invalid ISO-8601 time "{0}"; time-of-day must be in the format "hh:mm:ss.sss" or "hhmmss.sss" (with seconds and fractions of seconds optional) with valid values for each.
LEXER-15  = Invalid ISO-8601 datetime "{0}"; datetime must be in the format date+"T"+timeOfDay+timezone (with timezone optional), with valid values for each.
LEXER-16  = Invalid ISO-8601 timezone "{0}"; timezone must be "Z" (for UTC), or in the format "+hh:mm" or "+hhmm" (using either "+" or "-", and with minutes optional) with valid values for each.
LEXER-17  = Invalid ISO-8601 duration "{0}"; duration must be in the format "PnYnMnDTnHnMnS" (with the year, month, day, and time-of-day value optional, and the hours, minutes, and seconds values optional within the time-of-day portion), with valid values for each.
LEXER-18  = Unexpected character: "{0}".

PARSER-01 = Unknown fatal parser error: "{0}".
PARSER-02 = Unexpected End-Of-File (token exhaustion).
PARSER-03 = Expected token {0}; found {1}.
PARSER-04 = Bad version value.
PARSER-05 = Bad hex character: {0}.
PARSER-06 = Unsupported custom literal type: "{0}".
PARSER-07 = Cannot have module or package in a method.
PARSER-08 = Multiple assignment list required.
PARSER-09 = Empty statement is illegal.
PARSER-10 = Child type cannot be specified as non-narrowing.
PARSER-11 = Child type cannot have an access specifier ("{0}").
PARSER-12 = Case statement required first in a switch.
PARSER-15 = Either all dimensions have values, or none may.
PARSER-16 = Unexpected token: {0}. (Expected an EOF.)
PARSER-17 = Expected to find a type declaration.
PARSER-18 = No statements allowed outside of module declaration.
PARSER-19 = Repeated modifier: "{0}".
PARSER-20 = Conflicting modifiers: "{0}", "{1}".
PARSER-21 = Default switch branch is repeated.
PARSER-22 = Expression does not represent an L-Value.
PARSER-23 = Unexpected token following expression in template: "{0}".
PARSER-24 = Invalid path: "{0}".
PARSER-25 = Incompatible chained equality operators: Cannot mix "==" and "!=".
PARSER-26 = Incompatible chained ordering operators: Cannot mix "<"/"<=" and ">"/">=".
PARSER-27 = Unexpected keyword "{0}" indicates an extended type; use parenthesis around the type to enable the extended type syntax.


COMPILER-01 = Unknown fatal compiler error. {0}
COMPILER-02 = Cannot nest a module.
COMPILER-03 = Package cannot be nested under "{0}".
COMPILER-04 = Class cannot be nested under "{0}".
COMPILER-05 = Property "{0}" is a duplicate.
COMPILER-06 = Property "{0}" cannot be nested under "{1}".
COMPILER-07 = Illegal module name.
COMPILER-08 = Duplicate modifier.
COMPILER-09 = Illegal modifier.
COMPILER-10 = Conflicting modifier.
COMPILER-11 = More than one "extends" clause.
COMPILER-12 = Illegal / unexpected type parameters.
COMPILER-13 = Validator parameters are not allowed.
COMPILER-14 = Constructor parameters must have default values.
COMPILER-15 = Unexpected keyword ("{0}").
COMPILER-16 = Inner const class must be declared static if its outer class is not a const or a service.
COMPILER-17 = Inner service class must be declared static if its outer class is not a const or a service.
COMPILER-18 = Wrong number of type parameter values.
COMPILER-19 = Type parameter name "{0}" is a duplicate.
COMPILER-20 = More than one "import" clause.
COMPILER-21 = More than one "into" clause.
COMPILER-22 = Package cannot have both body and "import" clause.
COMPILER-23 = A conditional is not allowed on this structure.
COMPILER-24 = Cannot find a module "{0}".
COMPILER-25 = Conflicting version clauses.
COMPILER-26 = An import of the primary module cannot specify import modifiers or versions.
COMPILER-27 = Illegal link-time conditional expression.
COMPILER-28 = Duplicate import with the same alias: "{0}".
COMPILER-29 = Import cannot be conditional; condition ignored.
COMPILER-30 = Unresolvable name: "{0}".
COMPILER-31 = Name collision: "{0}".
COMPILER-32 = Not a class type: "{0}".
COMPILER-33 = Method "{0}" cannot be nested under "{1}".
COMPILER-34 = Typedef "{0}" cannot be nested under "{1}".
COMPILER-35 = Annotation cannot occur here.
COMPILER-36 = Could not find name "{0}" within "{1}".
COMPILER-37 = Name "{0}" is ambiguous.
COMPILER-38 = Name "{0}" is unresolvable.
COMPILER-39 = Name "{0}" is unhideable; attempt to hide "{1}" is an error.
COMPILER-40 = Return is supposed to be void.
COMPILER-41 = Return is supposed to be non-void.
COMPILER-42 = Return has the wrong number of arguments: {0} expected, {1} found.
COMPILER-43 = Type mismatch: "{0}" expected, "{1}" found.
COMPILER-44 = Wrong number of values: {0} expected, {1} found.
COMPILER-45 = Value of type "{0}" is out of range: {1}.
COMPILER-46 = Statement is not reachable.
COMPILER-47 = Expression does not evaluate to a constant value.
COMPILER-48 = A value is required.
COMPILER-49 = A return is required.
COMPILER-50 = Could not find an operation on "{0}" and "{1}" resulting in "{2}" type.
COMPILER-51 = Variable "{0}" is already defined.
COMPILER-52 = No "this" is available.
COMPILER-53 = No "super" method is available.
COMPILER-54 = The contribution type "{0}" must be parameterized.
COMPILER-55 = Method or function type requires complete parameter and return type information.
COMPILER-56 = Could not find a matching method or function "{0}" for type "{1}".
COMPILER-57 = Could not find an "outer this" named "{0}".
COMPILER-58 = Incompatible target type "{0}" for the method "{1}".
COMPILER-59 = The "this." prefix must be followed by a parent class or parent property identity.
COMPILER-60 = Because a previous argument specified a parameter name, the argument {0} must specify a parameter name
COMPILER-61 = Variable declaration cannot use conditional assignment.
COMPILER-62 = No-parameter constructor required for "{0}".
COMPILER-63 = Signature "{0}" is ambiguous.
COMPILER-64 = Type "{0}" has more than one default value for the type.
COMPILER-65 = Could not find a matching constructor for type "{0}".
COMPILER-66 = Tuple type has an unexpected number of field types; {0} expected, {1} found.
COMPILER-67 = Expression yields the type "{1}" that does not support the "{0}" operator.
COMPILER-68 = Expression yields the type "{1}" that does not support the "{0}" operator with the {2} specified parameters.
COMPILER-69 = The use of the "{0}" operator does not resolve to a single, unambiguous operator signature on the type "{1}".
COMPILER-70 = The expression cannot be assigned to.
COMPILER-71 = The left-hand-side of the Elvis expression is not nullable.
COMPILER-72 = The left-hand-side of the Elvis expression is only nullable.
COMPILER-73 = Short-circuiting expressions are not allowed in this context.
COMPILER-74 = The expression on the left-hand-side of the colon does not have the potential to use the expression on the right-hand-side.
COMPILER-75 = A "switch" can only contain one "default" statement and/or wildcard-match.
COMPILER-76 = A "switch" expression must contain a "default" statement and/or wildcard-match.
COMPILER-77 = The "switch" contains more than one "case" statement for the value: "{0}".
COMPILER-78 = A "switch" requires a constant value for the "case" statement.
COMPILER-79 = A "switch" must begin with a "case" statement.
COMPILER-80 = A "switch" cannot end with a "case" statement.
COMPILER-81 = The variable "{0}" is not definitely assigned.
COMPILER-82 = The variable "{0}" cannot be assigned to.
COMPILER-83 = Name required.
COMPILER-84 = Wrong number of arguments: {0} expected, {1} found.
COMPILER-85 = Parameter name is a duplicate: "{0}".
COMPILER-86 = Parameter types must be specified.
COMPILER-87 = Auto-narrowing override ('!') is not allowed.
COMPILER-88 = Could not find the specified label "{0}".
COMPILER-89 = Could not find an enclosing "for", "do", "while", or "switch" statement.
COMPILER-90 = A "continue" statement can only be applied to an enclosing "for", "do", "while", or "switch" statement.
COMPILER-91 = The expression type is not nullable: "{0}".
COMPILER-92 = The types "{0}" and "{1}" are not comparable.
COMPILER-93 = A duplicate name is used for the label "{0}".
COMPILER-94 = The specified label variable "{0}" is not available for the label "{1}".
COMPILER-95 = Index value {0} out-of-range; must be between {1} and {2} (inclusive).
COMPILER-96 = The anonymous inner class is of an invalid type.
COMPILER-97 = Anonymous inner class cannot extend both "{0}" and "{1}".
COMPILER-98 = Anonymous inner class cannot extend a class of the "{0}" category.
COMPILER-99 = Anonymous inner class is declared such that it must be both mutable and immutable.
COMPILER-100 = An anonymous inner class may not specify a union type.
COMPILER-101 = The initialization of the property "{0}" is implied by a constructor parameter, but the property does not exist or not settable.
COMPILER-102 = The initialization of the property "{0}" is implied by a constructor parameter, but the property type does not match; the expected type is {1} but the property is of type {2}.
COMPILER-103 = The implicit super class constructor from {0} does not exist on the class {1}.
COMPILER-104 = The "super" function has been used as if it were a normal object reference; it is normally used as a "super(...)" function call.
COMPILER-105 = The import name "{0}" is the same as the name of an existing variable.
COMPILER-106 = The import "{0}" does not refer to an identity.
COMPILER-107 = A "this" reference is required to access the "{0}" property of the "{1}" type.
COMPILER-108 = A "this" reference is required to access the "{0}" method of the "{1}" type.
COMPILER-109 = Missing "@Override" annotation on "{0}": This virtual child has a super virtual child.
COMPILER-110 = Invalid "@Override" annotation on "{0}": This virtual child does not have a super virtual child.
COMPILER-111 = Illegal "extends" clause on "{0}": This virtual child has a super virtual child.
COMPILER-112 = Illegal "extends" clause on interface "{0}": A super virtual child class exists of the same name, and an interface may not extend a class.
COMPILER-113 = Illegal explicit "extends" clause on virtual child "{0}": The virtual child super is implicit.
COMPILER-114 = A super virtual child interface exists of the same name "{0}", and a class may not extend an interface.
COMPILER-115 = Multiple super virtual child classes exists of the same name "{0}", and a class may not extend multiple classes.
COMPILER-116 = The "case" statement has an illegal number of values.
COMPILER-117 = Expected either a "break" (to exit the switch) or "continue" (to fall through); a block within a "switch" statement must not complete normally.
COMPILER-118 = The "catch" clause for "{0}" is unreachable because "{1}" was caught by a previous "catch" clause.
COMPILER-119 = No access can be specified for the static property "{0}" in the method "{1}".  
COMPILER-120 = Only private access can be specified for the property "{0}" in the method "{1}".
COMPILER-121 = The "set" access must not be specified on the static property "{0}" on "{1}".
COMPILER-122 = The "set" access is more accessible than the "get" access for property "{0}" on "{1}".
COMPILER-123 = Type "{0}" does not provide a default value. Use "new Array<Element>(...)" instead.
COMPILER-124 = Name is reserved: "{0}".
COMPILER-125 = Function is not allowed: "{0}".
COMPILER-126 = Function cannot be abstract: "{0}".
COMPILER-127 = Abstract function cannot be called directly: "{0}".
COMPILER-128 = The condition for a "while" loop must not evaluate to a constant "False".
COMPILER-129 = The name "{0}" is not a function.
COMPILER-130 = The short-circuited expression is always "Null".
COMPILER-131 = The delegation property "{0}" does not exist.
COMPILER-132 = The delegation type for the property "{0}" does not match; the expected type is "{1}", but the property is of type "{2}".
COMPILER-133 = Method "{0}" already exists.
COMPILER-134 = The evaluating expression "{0}" has a type of "ecstasy.Type"; it cannot match type "{1}". 
COMPILER-135 = A simple formal type is expected.
COMPILER-136 = Dynamic type parameters are not supported.
COMPILER-137 = The evaluating expression "{0}" has a type of "{1}"; it always matches type "{2}".
COMPILER-138 = Possible name collision: an attempt to use function "{0}" defined at "{1}" as an invocation target.
COMPILER-139 = Illegal usage of the method "{0}" with a conditional return type.
COMPILER-140 = Annotation "{0}" is not applicable to "{1}".
COMPILER-141 = The argument name is not allowed.
COMPILER-142 = Method name "{0}" collides with a property of the same name on class "{1}".
COMPILER-143 = Property name "{0}" collides with a method of the same name on class "{1}".
COMPILER-144 = Function "{0}" refers to a generic type "{1}".
COMPILER-145 = Unresolvable type parameter(s): {0}.
COMPILER-146 = Property reference ('&') is invalid.
COMPILER-147 = Validator cannot be abstract.
COMPILER-148 = A duplicate name is used for a class or package: "{0}"
COMPILER-149 = Virtual child "{0}" cannot be new''ed until after the parent has been constructed.
COMPILER-150 = Parameter {0} ("{1}") type mismatch for method "{2}"; required "{3}", actual "{4}".
COMPILER-151 = Return type mismatch for method "{0}"; required "{1}", actual "{2}".
COMPILER-152 = Return count mismatch for method "{0}"; required {1}, actual {2}.
COMPILER-153 = Argument "{0}" must have a default value.
COMPILER-154 = The Map constant contains duplicate keys: {0}.
COMPILER-155 = Non-terminating loop.
COMPILER-156 = Construct target "{0}" is not in the inheritance chain.
COMPILER-157 = Super class constructor is skipped.
COMPILER-158 = An assertion used as an expression must throw (must not complete).
COMPILER-159 = An "outer" reference to "{0}" is required to access the "{1}" property.
COMPILER-160 = An "outer" reference to "{0}" is required to access the "{1}" method.
COMPILER-161 = Virtual constructor must be public and abstract.
COMPILER-162 = Property "{0}" on the "{1}" type is not accessible.
COMPILER-163 = Illegal literal value: "{0}".
COMPILER-164 = The Set constant contains duplicate values: {0}.
COMPILER-165 = Injection cannot be combined with any other Ref annotations.
COMPILER-166 = Constant "{0}" refers to a generic type "{1}".
COMPILER-167 = An explicitly asynchronous invocation \“^()\” is indicated, but an invocation is not actually being performed.
COMPILER-168 = Switch expression return types are not uniform.
COMPILER-169 = "{0}" is not an instantiable abstract type.
COMPILER-170 = "{0}" is not an instantiable singleton type.
COMPILER-171 = "{0}" is not an instantiable type because it contains an abstract property "{1}".
COMPILER-172 = "{0}" is not an instantiable type because it contains an abstract method "{1}".
COMPILER-173 = "{0}" is not an instantiable type because its child "{1}" has an abstract property "{2}".
COMPILER-174 = "{0}" is not an instantiable type because its child "{1}" has an abstract method "{2}".
COMPILER-175 = "{0}" is not a virtual child to the provided parent type "{1}".
COMPILER-176 = The method "{0}" cannot be called from within construct() because "this" is a reference to the struct, and not to the object.
COMPILER-177 = Method "{0}" on the "{1}" type is not accessible.
COMPILER-178 = Possible name collision: an attempt to use property "{0}" defined at "{1}" as a function.
COMPILER-179 = Type parameter "{0}" inaccessible from static child class "{1}".
COMPILER-180 = The form of the expression cannot be used as a statement.
COMPILER-181 = Too many conditions for an "is" switch.
COMPILER-182 = Method on a singleton class cannot be abstract: "{0}".
COMPILER-183 = "{0}" is a formal type; use "new {0}(...)" instead of "{0}.new(...)".
COMPILER-184 = "The literal path expression type is ambiguous; specify a literal type prefix, such as "Path:", "FileStore:", "Directory:", or "Path:"."
COMPILER-185 = Circular value initializer for property "{0}".
COMPILER-186 = The "super" function is not defined within a non-virtual constructor.
COMPILER-187 = The evaluating expression "{0}" of type "{1}" can never match type "{2}".
COMPILER-188 = The specified arguments for the constructor of the contribution are unused because an explicit constructor is present.
COMPILER-189 = Property "{0}" is reserved and cannot be overridden.
COMPILER-190 = Property "{0}" collides with a property of the same name but different type on "{1}".
COMPILER-191 = A "switch" cannot end with a "continue" statement.
COMPILER-192 = Singleton type required.
COMPILER-193 = The "using" clause must specify an implementation of the ResourceProvider interface.
COMPILER-194 = The delegation target must be a property.
COMPILER-195 = A super method indicated by @Override cannot be found.
COMPILER-NI  = "{0}" is not yet implemented.

VERIFY-01 = Unknown fatal verifier error: "{0}".
VERIFY-02 = "{0}" does not have type parameters, but type parameters were provided.
VERIFY-03 = "{0}" requires "{1}" type parameters, but "{2}" type parameters were provided.
VERIFY-04 = "{0}" type parameter "{1}" must be of type "{2}", but has been overridden as "{3}" by {4}.
VERIFY-05 = "{0}" type parameter "{1}" must be of type "{2}", but has been specified as "{3}" by {4}.
VERIFY-06 = "{0}" type parameter "{1}" is specified as two different types ("{2}" and "{3}") by {4}.
VERIFY-07 = "{0}" is annotated by type "{1}", but it is not an explicit class identity.
VERIFY-08 = Unexpected "extends" "{0}" on "{1}"; an "extends" specifier cannot occur on interfaces (or on the root Object), there must be only one, and it must occur first (after any annotations, and after the "into" for a mixin).
VERIFY-09 = "{0}" is missing "extends".
VERIFY-10 = "{0}" "extends" "{1}", but it is not an explicit class identity.
VERIFY-11 = Class "{0}" contains a cyclical "{1}" contribution.
VERIFY-12 = "{0}" "implements" "{1}", but it is not an explicit class identity.
VERIFY-13 = Unexpected annotation "{0}" on "{1}"; annotations can only appear in the beginning of the contribution list.
VERIFY-14 = Unexpected "into" "{0}" on "{1}"; an "into" specifier can only occur on a mixin, there must be only one, and it must occur first (after any annotations).
VERIFY-15 = Unexpected "incorporates" "{0}" on "{1}"; an "incorporates" specifier cannot occur on an interface.
VERIFY-16 = "{0}" is incorporated by type "{1}", but it is not an explicit class identity.
VERIFY-17 = "{0}" is incorporated by type "{1}", but it is not a mixin.
VERIFY-18 = "{0}" incorporates "{1}", but "{2}" is not compatible with the "into" specifier: "{3}".
VERIFY-19 = "{0}" is delegated by type "{1}", but it is not an interface type.
VERIFY-20 = "{0}" is implemented by type "{1}", but it is not an interface type.
VERIFY-21 = Unexpected "delegates" "{0}" on "{1}"; a "delegates" specifier cannot occur on an interface.
VERIFY-22 = Unexpected formal type name "{0}" encountered while resolving "{1}".
VERIFY-23 = "{0}", which is a "{1}", illegally extends "{2}", which is a "{3}".
VERIFY-24 = Service type "{0}" cannot be treated as an immutable type.
VERIFY-25 = Redundant immutable type specification.
VERIFY-26 = Type "{0}" cannot be annotated because it does not specify a class or interface.
VERIFY-27 = "{0}" is not a mixin, and thus cannot be used in an annotation.
VERIFY-28 = The annotation "@{0}" is repeated.
VERIFY-29 = Type "{0}" cannot have accessibility defined because it does not specify a class or interface.
VERIFY-30 = "{0}" is extended by mixin type "{1}", but it is not a mixin.
VERIFY-31 = "{0}" is not a type that can be parameterized.
VERIFY-32 = "{0}" is annotated by "{1}", but is not compatible with the required "into": "{2}".
VERIFY-33 = "{0}" type parameter "{1}" is of type "{2}", which conflicts with the type parameter contribution from "{3}" of type "{4}".
VERIFY-34 = "{0}" type parameter "{1}" is not specified, which conflicts with the type parameter contribution from "{2}" of type "{3}".
VERIFY-35 = "{0}" type parameter "{1}" is of type "{2}", which conflicts with the type parameter contribution from "{3}" of the unspecified type.
VERIFY-36 = "{0}" contains a property "{1}" which collides with a type parameter of the same name.
VERIFY-37 = "{0}" missing a property "{1}" for the type parameter of the same name.
VERIFY-38 = "{0}" has a misconfigured property "{1}" for the type parameter of the same name.
VERIFY-39 = The "{0}" property on "{1}" is annotated by "{2}", which is an incompatible mixin for a property.
VERIFY-40 = The "get()" method on the "{1}" property on "{0}" is ambiguous.
VERIFY-41 = The "get()" method on the "{1}" property on "{0}" does not match the property type.
VERIFY-42 = The "set()" method on the "{1}" property on "{0}" is ambiguous.
VERIFY-43 = The "set()" method on the "{1}" property on "{0}" does not match the property type.
VERIFY-44 = Interface "{0}" contains an illegal property declaration for "{1}": Interface properties cannot include an implementation.
VERIFY-45 = Interface "{0}" contains an illegal property declaration for "{1}": Interface properties cannot include Ref or Var annotations.
VERIFY-46 = Interface "{0}" contains an illegal property declaration for "{1}": Interface properties must not specify @Inject.
VERIFY-47 = Property "{0}" overrides the property "{1}", so it must specify @Override.
VERIFY-48 = "{0}" contains an @RO property "{1}" that has a "set()" that uses a Var annotation or "super".
VERIFY-49 = "{0}" contains an @Inject property "{1}"  that also implements "get()", "set()", or has a Ref or Var annotation.
VERIFY-50 = "{0}" contains an @RO property "{1}" that does not have a "get()" and is not annotated with "@Abstract", "@Override", or "@Inject".
VERIFY-51 = "{0}" contains an @Override property "{1}", but no property declaration exists to override.
VERIFY-52 = "{0}" contains a duplicate annotation: "{1}".
VERIFY-53 = "{0}" contains a duplicate incorporates clause: "{1}".
VERIFY-54 = "{0}" contains a duplicate delegates clause: "{1}".
VERIFY-55 = "{0}" contains a duplicate implements clause: "{1}".
VERIFY-56 = The property "{1}" on "{0}" contains a duplicate initializer function.
VERIFY-57 = The constant property "{1}" on "{0}" contains custom code.
VERIFY-58 = The access for the "{1}" property on "{0}" is illegally specified as "struct".
VERIFY-59 = The Ref access is more restricted than the Var access for the "{1}" property on "{0}".
VERIFY-60 = The constant property "{1}" on "{0}" does not have an initial value.
VERIFY-61 = The constant property "{1}" on "{0}" has more than one initial value.
VERIFY-62 = The constant property "{1}" on "{0}" is declared as @Abstract.
VERIFY-63 = The constant property "{1}" on "{0}" is declared as a read/write property.
VERIFY-64 = The declaration of the "{1}" property on "{0}" implies both a read-only and a read/write property.
VERIFY-65 = The super method for "{0}" is ambiguous.
VERIFY-66 = Property information for "{0}" contains both a regular property and a type parameter.
VERIFY-67 = Property information for "{0}" contains conflicting types "{1}" and "{2}".
VERIFY-68 = Property information for "{0}" contains conflicting constant information.
VERIFY-69 = "{0}" contains multiple methods that attempt to narrow "{1}", including "{2}"; only a single narrowing method can exist, unless the method being narrowed is also extended without being narrowed, such that it remains accessible.
VERIFY-70 = A super method for "{0}" on "{1}" is indicated by the "@Override" annotation, but cannot be found.
VERIFY-71 = The interface property "{1}" on "{0}" is declared as @Abstract; that annotation is not permitted.
VERIFY-72 = An annotation on the constant "{1}" on "{0}" is illegal: Constants cannot include Ref or Var annotations.
VERIFY-73 = The @Override annotation on the constant "{1}" on "{0}" is illegal.
VERIFY-74 = The function "{0}" contains a property "{1}"; functions must not contain properties.
VERIFY-75 = The annotation "{2}" on property "{1}" on "{0}" duplicates an annotation that is already present from the base property; the annotation on the derived property is ignored.
VERIFY-76 = The annotation "{2}" on property "{1}" on "{0}" is a super-class of the annotation "{3}" that is already present from the base property; the annotation on the derived property is ignored.
VERIFY-77 = The property "{1}" on "{0}" attempts to declare a Var property, but the setter on the base is private.
VERIFY-78 = Interface "{0}" contains an illegal property declaration for "{1}": An interface property must be declared as @RO to specify a default get() implementation.
VERIFY-79 = The access for the "{1}" property on "{0}" is defined more restrictively than its base.
VERIFY-80 = "{0}" attempts to override the method "{1}" on "{2}", but the method cannot be overridden.
VERIFY-81 = "{0}" attempts to override the method "{1}" on "{2}", but does not specify @Override.
VERIFY-82 = Unexpected auto-narrowing contribution "{0}" for type "{1}"
VERIFY-83 = A virtual child "{0}" cannot be found on "{1}".
VERIFY-84 = "{0}" contains more than one component with the name "{1}".
VERIFY-85 = While resolving "{0}", a child with the name "{1}" from the contribution "{2}" collided with the existing child "{3}".
VERIFY-86 = "{0}" is not an instantiable; it does not implement a virtual constructor "{1}".
VERIFY-87 = The access for the method "{1}" on "{0}" is defined more restrictively than its base.
VERIFY-88 = The type modifier is not permitted for contribution "{1}" on "{0}".