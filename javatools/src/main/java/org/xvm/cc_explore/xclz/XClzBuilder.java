package org.xvm.cc_explore.xclz;

import org.xvm.cc_explore.*;
import org.xvm.cc_explore.cons.*;
import org.xvm.cc_explore.util.SB;

import java.util.HashMap;
import javax.lang.model.SourceVersion;


// Some kind of base class for a Java class that implements an XTC Module
public class XClzBuilder {
  public final ModPart _mod;
  public final SB _sb;
  public XClz _xclz;            // Java class

  public MethodPart _meth;      // Method whose code is being parsed
  private CPool _pool;          // Parser for code buffer
  public int _lexical_depth;    // Lexical scope depth
  public final HashMap<String,String> _names; // Java namification

  
  public XClzBuilder( ModPart mod ) {
    System.err.println("Making XClz for "+mod);
    _mod = mod;
    _sb = new SB();
    _names = new HashMap();

    // Let's start by assuming if we're here, we're inside the top-level
    // ecstasy package - otherwise we're nested instead the mirror for the
    // containing package.
    assert mod.child("ecstasy") instanceof PackagePart;

    // The Java class will extend XClz.
    // The Java class name will be the mangled module class-name.
    String java_class_name = "J"+mod._name;
    jclass_body(java_class_name);

    throw XEC.TODO();
  }

  // Fill in the body of the matching java class
  private void jclass_body( String java_class_name ) {
    _sb.p("// Auto Generated by XEC from ").p(_mod._dir._str).p(_mod._path._str).nl().nl();
    _sb.p("public class ").p(java_class_name).p(" {").nl().ii();
    
    // Look for a module init.  This will become the Java <clinit>
    MMethodPart mm = (MMethodPart)_mod.child("construct");
    MethodPart construct = (MethodPart)mm.child(mm._name);
    if( construct != null ) {
      assert construct._sibling==null;
      _sb.nl();
      _sb.ip("static {").nl();
      jcode(construct);
      _sb.ip("}").nl().nl();
    }

    // Output Java methods for all Module methods
    // TODO: Classes in a Module?
    for( Part part : _mod._name2kid.values() ) {
      if( part instanceof MMethodPart mmp ) {
        if( mmp._name.equals("construct") ) continue; // Already handled module constructor
        MethodPart meth = (MethodPart)mmp.child(mmp._name);
        jmethod(meth);
      } else if( part instanceof PackagePart pp ) {
        // Self module is OK
      } else {
        throw XEC.TODO();
      }
    }

    // End the class body
    _sb.di().p("}").nl();
  }
  
  // Emit a Java string for this MethodPart.
  // Already _sb has the indent set.
  private void jmethod( MethodPart m ) {
    if( m._rets==null ) _sb.ip("void ");
    else throw XEC.TODO();
    _sb.p(m._name).p("(");
    if( m._args!=null ) throw XEC.TODO();
    _sb.p(") {").nl();
    jcode(m);
    _sb.ip("}").nl().nl();
  }

  // Generate a Java string code for this MethodPart
  // Already wrapped in the `ret fcn_name(args) {` and `}`.
  // Already _sb has the indent set.
  private void jcode( MethodPart m ) {
    _meth = m;
    _pool = new CPool(m._code,1.2); // Setup the constant pool parser
    assert _lexical_depth==0;       // No scopes added
    assert _names.isEmpty();        // No names mapping yet
    _sb.ii();                       // Indent code
    int nops = u31();               // Number of opcodes (since varying size)
    for( int i=0; i<nops; i++ ) {
      int opn = u8();
      Op.OPS[opn]._emit.accept(this);
    }
    assert _lexical_depth==0;   // All scopes back to outer
    _names.clear();             // No names mapping
    _sb.di();                   // Un-indent code
  }

  int u8 () { return _pool.u8 (); }
  int u31() { return _pool.u31(); }
  long pack64() { return _pool.pack64(); }

  // --------------------------------------------------------------------------
  // Magic constant for indexing into the constant pool.
  private static final int CONSTANT_OFFSET = -17;
  // Read a method constant.  Advances the parse point.
  Const methcon() {
    long idx = pack64();
    assert idx < 0 && ((int)idx)==idx;
    return _meth._cons[CONSTANT_OFFSET - (int)idx];
  }

  // Return a java-valid name
  String jname_methcon() {
    String name = ((StringCon)methcon())._str;
    final HashMap<String,String> names = _names;
    return _names.computeIfAbsent(name, k -> {
        // Valid java name, just keep it
        if( SourceVersion.isIdentifier(k) && !SourceVersion.isKeyword(k) )
          return k;
        // Starts with "loop#", assume it is a generated loop variable for iterators
        if( k.startsWith("loop#") ) {
          if( !names.containsKey("i") ) return "i";
        }
        throw XEC.TODO();
      });
  }
  
  // Produce a java type from a method constant
  String jtype_methcon() {
    return jtype_ttcon( (TermTCon)methcon() );
  }
  
  // Produce a java type from a TermTCon
  String jtype_ttcon( TermTCon ttc ) {
    ClassPart clz = (ClassPart)ttc.part();
    if( clz._name.equals("Console") && clz._path._str.equals("ecstasy/io/Console.x") )
      return "java.io.PrintStream";
    if( clz._name.equals("Int64") && clz._path._str.equals("ecstasy/numbers/Int64.x") )
      return "long";
    if( clz._name.equals("Boolean") && clz._path._str.equals("ecstasy/Boolean.x") )
      return "boolean";
    throw XEC.TODO();
  }  

  // Produce a java value from a TCon
  String jvalue_tcon( TCon tc ) {
    if( tc instanceof IntCon ic ) {
      if( ic._big != null ) throw XEC.TODO();
      long x = ic._x;
      String s = ""+x;
      return (int)x == x ? s : s+"L";
    }
    throw XEC.TODO();
  }

  
  // Produce a java value from a TermTCon
  String jvalue_ttcon( TermTCon ttc ) {
    ClassPart clz = (ClassPart)ttc.part();
    if( clz._name.equals("Console") && clz._path._str.equals("ecstasy/io/Console.x") )
      return "System.out";
    throw XEC.TODO();
  }  
}
