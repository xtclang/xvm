package org.xvm.cc_explore.xclz;

import org.xvm.cc_explore.*;
import org.xvm.cc_explore.xrun.Container;
import org.xvm.cc_explore.xrun.NativeContainer;
import org.xvm.cc_explore.cons.*;
import org.xvm.cc_explore.util.*;

import java.lang.Character;
import java.util.HashMap;
import javax.lang.model.SourceVersion;
import java.lang.reflect.Constructor;

// Some kind of base class for a Java class that implements an XTC Module
public class XClzBuilder {
  public static final String ROOT = "org.xvm.cc_explore";
  public static final String XCLZ = ROOT+".xclz";

  
  public final ModPart _mod;
  public final SB _sb;
  // Fields for emitting a Method Code
  public MethodPart _meth;      // Method whose code is being parsed
  private CPool _pool;          // Parser for code buffer
  final HashMap<String,String> _names; // Java namification
  final NonBlockingHashMapLong<String> _locals, _ltypes; // Virtual register numbers to java names
  int _nlocals;                 // Number of locals defined; popped when lexical scopes pop

  // A collection of extra class source strings
  private static final HashMap<String,String> XCLASSES = new HashMap<>();

  public XClzBuilder( ModPart mod ) {
    _mod = mod;
    _sb = new SB();
    _names = new HashMap<>();
    _locals = new NonBlockingHashMapLong<>();
    _ltypes = new NonBlockingHashMapLong<>();
  }

  // Convert a local name to the local index
  long name2idx( String name ) {
    for( long l : _locals.keySetLong() )
      if( name.equals(_locals.get(l)) )
        return l;
    return -1;
  }

  
  // Let's start by assuming if we're here, we're inside the top-level
  // ecstasy package - otherwise we're nested instead the mirror for the
  // containing package.
  public XRunClz xclz() {
    assert _mod.child("ecstasy") instanceof PackagePart;
    assert XCLASSES.isEmpty();

    // The Java class will extend XClz.
    // The Java class name will be the mangled module class-name.
    String java_class_name = java_class_name(_mod);
    jclass_body(java_class_name);
    System.out.println(_sb);
    XCLASSES.clear();    
    
    try {
      Class<XRunClz> clz = XClzCompiler.compile(XCLZ+"."+java_class_name, _sb.toString());
      Constructor<XRunClz> xcon = clz.getConstructor(Container.class);
      return xcon.newInstance(new NativeContainer());
    } catch( Exception ie ) {
      throw XEC.TODO();
    }
  }

  
  // Fill in the body of the matching java class
  private void jclass_body( String java_class_name ) {
    _sb.p("// Auto Generated by XEC from ").p(_mod._dir._str).p(_mod._path._str).nl().nl();
    _sb.p("package ").p(XCLZ).p(";").nl().nl();
    _sb.p("import ").p(ROOT).p(".xrun.*;").nl();
    _sb.p("import static ").p(ROOT).p(".xrun.XRuntime.$t;").nl();
    _sb.nl();
    _sb.p("public class ").p(java_class_name).p(" extends XRunClz {").nl().ii();

    // Required constructor to inject the container
    _sb.ip("public ").p(java_class_name).p("( Container container ) { super(container); }").nl();
    
    // Look for a module init.  This will become the Java <clinit>
    MMethodPart mm = (MMethodPart)_mod.child("construct");
    MethodPart construct = (MethodPart)mm.child(mm._name);
    if( construct != null ) {
      assert _locals.isEmpty() && _nlocals==0; // No locals mapped yet
      assert construct._sibling==null;
      // Skip common empty constructor
      if( !construct.is_empty_function() ) {
        _sb.nl();
        _sb.ip("static {").nl();
        ast(construct).jcode(_sb );
        _sb.ip("}").nl().nl();
      }
    }

    // Output Java methods for all Module methods
    // TODO: Classes in a Module?
    for( Part part : _mod._name2kid.values() ) {
      if( part instanceof MMethodPart mmp ) {
        if( mmp._name.equals("construct") ) continue; // Already handled module constructor
        _sb.nl();
        MethodPart meth = (MethodPart)mmp.child(mmp._name);
        jmethod(meth);
      } else if( part instanceof PackagePart ) {
        // Self module is OK
      } else if( part instanceof PropPart pp ) {
        // Insert a <clinit> junk for this thing
        String jtype = jtype(pp._con,false);
        _sb.ip("private final ").p(jtype).p(" ").p(pp._name).p(" = ").p(jvalue_ttcon((TermTCon)pp._con)).p(";").nl();
        _sb.ip(jtype).p(" ").p(pp._name).p("$get() { return ").p(pp._name).p("; }").nl();
        
      } else {
        throw XEC.TODO();
      }
    }

    // End the class body
    _sb.di().p("}").nl();
    
    // Output extra helper classes, if any
    for( String source : XCLASSES.values() )
      _sb.nl().p(source);    
  }
  
  // Emit a Java string for this MethodPart.
  // Already _sb has the indent set.
  private void jmethod( MethodPart m ) {
    assert _locals.isEmpty() && _nlocals==0; // No locals mapped yet
    _sb.ip("public ");
    // Return type
    if( m._rets==null ) _sb.p("void ");
    else if( m._rets.length == 1 ) _sb.p(jtype(m._rets[0]._con,false)).p(' ');
    else throw XEC.TODO(); // Multi-returns will need much help
    // Argument list
    _sb.p(m._name).p("( ");
    if( m._args!=null ) {
      for( int i = 0; i < m._args.length; i++ ) {
        Parameter p = m._args[i];
        String type = jtype(p._con,false);
        _sb.p(type).p(' ').p(p._name).p(", ");
        define(p._name,type);
      }
      _sb.unchar(2);
    }
    _sb.p(" ) ");
    // Body    
    ast(m).jcode(_sb);
    _sb.nl();

    // Popped back to the original args
    assert (m._args==null ? 0 : m._args.length) == _nlocals;
    pop_locals(0);
  }

  AST ast( MethodPart m ) {
    // Build the AST from bytes
    _meth = m;
    _pool = new CPool(m._ast,m._cons); // Setup the constant pool parser
    AST ast = AST.parse(this);
    // Do any trivial restructuring
    return ast.do_rewrite();
  }

  
  int u8 () { return _pool.u8(); }  // Packed read
  int u31() { return _pool.u31(); } // Packed read
  long pack64() { return _pool.pack64(); }
  // Read an array of method constants
  Const[] consts() { return _pool.consts(); }
  // Read a single method constant, advancing parse pointer
  Const con() { return con(u31()); }
  // Read a single method constant
  Const con(int i) { return _meth._cons[i]; }

  // Read an array of AST kid terminals
  AST[] kids() { return _kids(u31(),0); }
  AST[] kids( int n ) { return _kids(n,0); }
  // Read an array of AST kid terminals, with a given bias (skipped elements are null).
  AST[] kids_bias( int b ) { return _kids(u31(),b); }
  
  private AST[] _kids( int n, int bias ) {
    if( n+bias==0 ) return null;
    AST[] kids = new AST[n+bias];
    for( int i=0; i<n; i++ )
      kids[i+bias] = AST.ast_term(this);
    return kids;
  }


  // --------------------------------------------------------------------------

  void define( String name, String type ) {
    // Track active locals
    _locals.put(_nlocals  ,name);
    _ltypes.put(_nlocals++,type);
  }
    // Pop locals at end of scope
  void pop_locals(int n) {
    while( n < _nlocals )
      _locals.remove(--_nlocals);
  }

  static String java_class_name( ModPart mod ) {
    return "J"+mod._name;
  }

  // After the basic mangle, dups are suffixed 1,2,3...
  String jname( String xname ) {
    String s = _mangle(xname);
    boolean unique = true;
    int max = 0;
    for( String old : _locals.values() ) {
      if( s.equals(old) ) unique = false;
      else if( old.startsWith(s) ) {
        int last = old.length();
        while( Character.isDigit(old.charAt(last-1)) ) last--;
        if( last == old.length() ) continue; // No trailing digits to confuse
        int num = Integer.parseInt(old.substring(last));
        max = Math.max(max,num);
      }
    }

    return unique ? s : s+(max+1);
  }

  // If the name is a valid java id, keep it.
  // If the name starts "loop#", use "i"
  // keep the valid prefix, and add $.
  private static String _mangle( String name ) {
    // Valid java name, just keep it
    // Valid except a keyword, add "$"
    if( SourceVersion.isIdentifier(name) )
      return SourceVersion.isKeyword(name) ? name+"$" : name;
    // Starts with "loop#", assume it is a generated loop variable for iterators
    if( name.startsWith("loop#") ) return "i";
    // Keep valid prefix and add "$"
    throw XEC.TODO();
  }


  // A set of common XTC classes, and their Java replacements.
  // These are NOT parameterized.
  static final HashMap<String,String> XJMAP = new HashMap<>() {{
      put("Console+ecstasy/io/Console.x","Console");
      put("Int64+ecstasy/numbers/Int64.x","long");
      put("Boolean+ecstasy/Boolean.x","boolean");
      put("StringBuffer+ecstasy/text/StringBuffer.x","StringBuffer");
      put("String+ecstasy/text/String.x","String");
      put("Char+ecstasy/text/Char.x","char");
    }};

  // Convert a primtive to the Java object version.
  static final HashMap<String,String> XBOX = new HashMap<>() {{
      put("char","Character");
      put("int","Integer");
      put("long","Long");
    }};
  static String box(String s) {
    String box = XBOX.get(s);
    return box==null ? s : box;
  }

  
  // Produce a java type from a TermTCon
  static String jtype( Const tc, boolean boxed ) {
    if( tc instanceof TermTCon ttc ) {
      ClassPart clz = (ClassPart)ttc.part();
      String key = clz._name + "+" + clz._path._str;
      String val = XJMAP.get(key);
      if( val!=null )
        return boxed ? box(val) : val;
      throw XEC.TODO();
    }
    if( tc instanceof ParamTCon ptc ) {
      String telem = ptc._parms==null ? null : jtype(ptc._parms[0],true);
      ClassPart clz = ((ClzCon)ptc._con).clz();
      if( clz._name.equals("Array") && clz._path._str.equals("ecstasy/collections/Array.x") ) {
        if( telem.equals("Long") )  return "AryI64"; // Java ArrayList specialized to int64
        return "Ary<"+telem+">"; // Shortcut class
      }
      if( clz._name.equals("Range") && clz._path._str.equals("ecstasy/Range.x") ) {
        if( telem.equals("Long") ) return "Range"; // Shortcut class
        else throw XEC.TODO();
      }
      if( clz._name.equals("List") && clz._path._str.equals("ecstasy/collections/List.x") )
        return "Ary<"+telem+">"; // Shortcut class
      if( clz._name.equals("Tuple") && clz._path._str.equals("ecstasy/collections/Tuple.x") )
        return tuple_class(ptc._parms);
      if( clz._name.equals("Function") && clz._path._str.equals("ecstasy/reflect/Function.x") )
        // TODO: Gonna need more type info that this
        return "XFunc";
      if( clz._name.equals("Type") && clz._path._str.equals("ecstasy/reflect/Type.x") )
        return telem + ".class";
          
      throw XEC.TODO();
    }
    if( tc instanceof ImmutTCon itc ) 
      return jtype(itc.icon(),boxed); // Ignore immutable for now
    
    throw XEC.TODO();
  }  

  // Return a tuple class for this set of types.  The class is cached, and can
  // be used many times.
  private static String tuple_class( TCon[] parms ) {
    assert ASB.len()==0;
    int N = parms==null ? 0 : parms.length;
    String[] clzs = new String[N];
    ASB.p("Tuple").p(N);
    for( int i=0; i<N; i++ )
      ASB.p("$").p(clzs[i]=jtype(parms[i],false));

    // Lookup cached version
    String tclz = ASB.toString();
    ASB.clear();
    if( N==0 ) return tclz;     // Tuple0 already exists in the base runtime
    if( !XCLASSES.containsKey(tclz) ) {
      /* Gotta build one.  Looks like:
         class Tuple3$long$String$char extends Tuple3 {
           public long _f0;
           public String _f1;
           public char _f2;
           Tuple(long f0, String f1, char f2) {
             _f0=f0; _f1=f1; _f2=f2;
           }
           public Object f0() { return _f0; }
           public Object f1() { return _f1; }
           public Object f2() { return _f2; }
         }
      */
      // Tuple N class
      ASB.p("class ").p(tclz).p(" extends Tuple"+N+" {").nl().ii();
      // N field declares
      for( int i=0; i<N; i++ )
        ASB.ip("public ").p(clzs[i]).p(" _f").p(i).p(";").nl();
      // Constructor, taking N arguments
      ASB.ip(tclz).p("( ");
      for( int i=0; i<N; i++ )
        ASB.p(clzs[i]).p(" f").p(i).p(", ");
      ASB.unchar(2).p(") {").nl().ii().i();
      // N arg to  field assigns
      for( int i=0; i<N; i++ )
        ASB.p("_f").p(i).p("=").p("f").p(i).p("; ");
      ASB.nl().di().ip("}").nl();
      // Abstract accessors
      for( int i=0; i<N; i++ )
        ASB.ip("public Object f").p(i).p("() { return _f").p(i).p("; }").nl();
      // Abstract setters
      for( int i=0; i<N; i++ )
        ASB.ip("public void f").p(i).p("(Object e) { _f").p(i).p("= (").p(box(clzs[i])).p(")e; }").nl();
      // Class end
      ASB.di().ip("}").nl();
      XCLASSES.put(tclz,ASB.toString());
      ASB.clear();
    }

    return tclz;
  }

  
  // Produce a java value from a TCon
  private static final SB ASB = new SB();
  static public String value_tcon( TCon tc ) {
    assert ASB.len()==0;
    value_tcon(ASB,tc);
    String rez = ASB.toString();
    ASB.clear();
    return rez;
  }
  private static SB value_tcon( SB asb, TCon tc ) {
    // Integer constants in XTC are Java Longs
    if( tc instanceof IntCon ic ) {
      if( ic._big != null ) throw XEC.TODO();
      return ASB.p(ic._x).p('L');
    }

    // Character constant
    if( tc instanceof CharCon cc )
      return ASB.p('\'').p((char)cc._ch).p('\'');

    // String constants
    if( tc instanceof StringCon sc )
      return ASB.p('"').escape(sc._str).p('"');
    
    // Array constants
    if( tc instanceof AryCon ac ) {
      assert ac.type() instanceof ImmutTCon; // Immutable array goes to static
      String type = jtype(ac.type(),false);
      int lastx = type.length()-1;
      char ch = type.charAt(lastx);
      
      if( ch!=']' ) { // e.g. AryI64 or Ary<AryI64>
        // Generic Ary flavors.
        int genx = type.indexOf('<');
        String  genclz = ch=='>' ? type.substring(genx+1,lastx) : null;
        String baseclz = ch=='>' ? type.substring(0,genx) : type;        
        ASB.p("new ").p(baseclz);

        if( baseclz.contains("Tuple") ) {
          ASB.p("(");
          if( ac.cons()!=null ) {
            for( Const con : ac.cons() )
              value_tcon( ASB, (TCon)con ).p(", ");
            ASB.unchar(2);
          }
          ASB.p(")");
        } else {
          
          assert baseclz.startsWith("Ary");          
          ASB.p("(");
          if( genclz != null ) ASB.p(genclz).p(".class");
          ASB.p(")");
        
          if( ac.cons()!=null )
            for( Const con : ac.cons() )
              value_tcon( ASB.p(".add("), (TCon)con ).p(")");
        }

      } else {
        // Standard arrays, e.g. long[]
        ASB.p("new ").p(type).p("[]");
        if( ac.cons()!=null ) {
          ASB.p("{ ");
          for( Const con : ac.cons() )
            value_tcon( ASB, (TCon)con ).p(", ");
          ASB.p("}");
        }
      }
      return ASB;
    }

    // Enums
    if( tc instanceof EnumCon econ ) {
      ClassPart clz = (ClassPart)econ.part();
      // XTC Booleans rewrite as Java booleans
      if( clz._super._name.equals("Boolean") ) 
        return ASB.p(clz._name.equals("False") ? "false" : "true");
      // Intercept Tuple enums
      if( clz._super._name.equals("Mutability") ) {
        if( clz._super._par._name.equals("Tuple") ) {
          return ASB.p("Tuple.Mutability.").p(clz._name);          
        } else
          throw XEC.TODO();
      }
      throw XEC.TODO();
    }
    
    // Literal constants
    if( tc instanceof LitCon lit )
      return ASB.p(lit._str);
    
    // Method constants
    if( tc instanceof MethodCon mcon )  {
      MethodPart meth = (MethodPart)mcon.part();
      // TODO: Assumes the method is in the local Java namespace
      return ASB.p(meth._name);
    }

    // Singleton class constants
    if( tc instanceof SingleCon con0 )
      return ASB.p(java_class_name((ModPart)con0.part()));

    // Property constant.  Just the base name, and depending on usage
    // will be either console$get() or console$set(value).
    if( tc instanceof PropCon prop )
      return ASB.p(prop._name);

    // A class Type as a value
    if( tc instanceof ParamTCon ptc ) {
      return ASB.p(jtype(ptc,false));
    }
    
    throw XEC.TODO();
  }

  // Produce a java value from a TermTCon
  static String jvalue_ttcon( TermTCon ttc ) {
    ClassPart clz = ttc.clz();
    if( clz._name.equals("Console") && clz._path._str.equals("ecstasy/io/Console.x") )
      return "_container.console()";
    throw XEC.TODO();
  }  
}
