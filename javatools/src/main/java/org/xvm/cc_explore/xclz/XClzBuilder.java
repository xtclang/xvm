package org.xvm.cc_explore.xclz;

import org.xvm.cc_explore.*;
import org.xvm.cc_explore.cons.*;
import org.xvm.cc_explore.util.*;
import org.xvm.cc_explore.xrun.*;

import static org.xvm.cc_explore.xclz.XType.*;

import java.lang.Character;
import java.util.HashMap;
import javax.lang.model.SourceVersion;
import java.lang.reflect.Constructor;


// XTC Module is roughly a java package, but I don't want to deal with directories
// So a module becomes "JModXNAME extends XClz" class.
// Then a XTC class file (can be inside a single-class module file)
// extends this: "JClzTest extends JModTest".




// Some kind of base class for a Java class that implements an XTC Module
public class XClzBuilder {

  // XTC Module, which is also the top-level Java class
  public final ModPart _mod;
  public final String _java_mod_name;
  public final Base _type;
  // Top level, vs e.g. nested inner class
  public final boolean _top;
  // Java code
  public final SB _sb;
  // Fields for emitting a Method Code
  public MethodPart _meth;      // Method whose code is being parsed
  private CPool _pool;          // Parser for code buffer
  final HashMap<String,String> _names; // Java namification
  final NonBlockingHashMapLong<String> _locals; // Virtual register numbers to java names
  final NonBlockingHashMapLong<XType>  _ltypes; // Virtual register numbers to java types
  int _nlocals;                 // Number of locals defined; popped when lexical scopes pop

  // A collection of extra class source strings
  static final HashMap<String,String> XCLASSES = new HashMap<>();

  public  XClzBuilder( ModPart mod        ) { this(mod,new SB(),true ); }
  public  XClzBuilder( ModPart mod, SB sb ) { this(mod,    sb  ,false); }
  private XClzBuilder( ModPart mod, SB sb, boolean top ) {
    _mod = mod;
    _top = top;
    _sb = sb;
    _java_mod_name = java_class_name(_mod._name);
    _type = Base.make(_java_mod_name);
    _names = new HashMap<>();
    _locals = new NonBlockingHashMapLong<>();
    _ltypes = new NonBlockingHashMapLong<>();
  }

  // Convert a local name to the local index
  long name2idx( String name ) {
    for( long l : _locals.keySetLong() )
      if( name.equals(_locals.get(l)) )
        return l;
    return -1;
  }

  
  // Let's start by assuming if we're here, we're inside the top-level
  // ecstasy package - otherwise we're nested instead the mirror for the
  // containing package.
  public XRunClz xclz() {
    assert _mod.child("ecstasy") instanceof PackagePart;
    assert XCLASSES.isEmpty();

    // The Java class will extend XClz.
    // The Java class name will be the mangled module class-name.
    jclass(_mod);
    // Output extra helper classes, if any
    for( String source : XCLASSES.values() )
      _sb.nl().p(source);    
    XCLASSES.clear();
    
    System.out.println(_sb);
    
    try {
      Class<XRunClz> clz = XClzCompiler.compile(XEC.XCLZ+"."+_java_mod_name, _sb.toString());
      Constructor<XRunClz> xcon = clz.getConstructor(Container.class);
      return xcon.newInstance(new NativeContainer());
    } catch( Exception ie ) {
      throw XEC.TODO();
    }
  }

  
  // Fill in the body of the matching java class
  private void jclass( ClassPart clz ) {
    _sb.p("// Auto Generated by XEC from ").p(_mod._dir._str).p(clz._path._str).nl().nl();
    _sb.p("package ").p(XEC.XCLZ).p(";").nl().nl();
    _sb.p("import ").p(XEC.ROOT).p(".xrun.*;").nl();
    _sb.p("import static ").p(XEC.ROOT).p(".xrun.XRuntime.$t;").nl();
    _sb.nl();
    jclass_body( clz );
  }

  // Java Class body; can be nested (static inner class)
  private void jclass_body( ClassPart clz ) {
    String java_class_name = java_class_name(clz._name);
    _sb.ip("// XTC ").p(_top ? "module ": "class ").p(clz._path._str).p(":").p(clz._name).p(" as Java class ").p(java_class_name).nl();

    if( _top ) {
      _sb.p("public class ").p(java_class_name).p(" extends XRunClz");
    } else {
      _sb.ip("public static class ").p(java_class_name).p(" extends ");
      _sb.p(clz._f==Part.Format.CONST ? "XConst" : "XClz");
    }
    _sb.p(" {").nl().ii();

    // Required constructor to inject the container
    if( _top )
      _sb.ip("public ").p(java_class_name).p("( Container container ) { super(container); }").nl();
    
    // Look for a module/class init.  This will become the Java <clinit> / <init>
    MMethodPart mm = (MMethodPart)clz.child("construct");
    MethodPart construct = (MethodPart)mm.child(mm._name);
    if( construct != null ) {
      assert _locals.isEmpty() && _nlocals==0; // No locals mapped yet
      assert construct._sibling==null;
      // Skip common empty constructor
      if( !construct.is_empty_function() ) {
        _sb.nl();
        if( _top ) {
          _sb.ip("static {").nl();
          ast(construct).jcode(_sb );
          _sb.ip("}").nl().nl();
        } else {
          _sb.i();
          jmethod_body(construct,java_class_name);
        }
      }
    }

    // Output Java methods for all Module methods
    // TODO: Classes in a Module?
    MethodPart run=null;
    for( Part part : clz._name2kid.values() ) {
      if( part instanceof MMethodPart mmp ) {
        if( mmp._name.equals("construct") ) continue; // Already handled module constructor
        _sb.nl();
        MethodPart meth = (MethodPart)mmp.child(mmp._name);
        if( meth == null && clz._f == Part.Format.CONST ) {
          XConst.make_meth(clz,mmp._name,_sb);
        } else {
          if( mmp._name.equals("run") ) run = meth; // Save the top-level run method
          jmethod(meth,meth._name);
        }
      } else if( part instanceof PackagePart ) {
        // Self module is OK
      } else if( part instanceof PropPart pp ) {
        XProp.make_class(_mod,_sb,pp); // <clinit> for a static global property
      } else if( part instanceof ClassPart clz_nest ) {
        // Nested class.  Becomes a java static inner class
        XClzBuilder X = new XClzBuilder(_mod,_sb);
        X.jclass_body(clz_nest);
        
      } else {
        throw XEC.TODO();
      }
    }

    // If the run method has a string array arguments -
    // - make a no-arg run, which calls the arg-run with nulls.
    // - make a main() which forwards to the arg-run
    if( _top && run != null && run._args != null ) {
      _sb.ip("public void run() { run(new Ary<String>(new String[0])); }").nl();
      _sb.ip("public void main(String[] args) {").nl().ii();
      _sb.ip(" run( new Ary<String>(args) );").nl().di();
      _sb.ip("}").nl();
    }

    // End the class body
    _sb.di().ip("}").nl();
    // Install for future reference
    XType.install(clz,java_class_name);
  }

  // Emit a Java string for this MethodPart.
  // Already _sb has the indent set.
  public void jmethod( MethodPart m, String mname ) {
    assert _locals.isEmpty() && _nlocals==0; // No locals mapped yet
    _sb.ip("public ");
    if( (m._nFlags & Part.STATIC_BIT)!=0 ) _sb.p("static ");
    // Return type
    XType[] xrets = XType.xtypes(m._rets);
    if( xrets==null ) _sb.p("void ");
    else if( xrets.length == 1 ) xrets[0].p(_sb).p(' ');
    else if( m.is_cond_ret() ) {
      // Conditional return!  Passes the extra return in XRuntime$COND.
      // The m._rets[0] is the boolean
      xrets[1].p(_sb).p(' ');
    } else {
      throw XEC.TODO(); // Multi-returns will need much help
    }
    jmethod_body(m,mname);
  }

  // Name, argument list, body:
  //
  // ...method_name( int arg0, String arg1, ...) {
  //   ...indented_body
  //   }
  public void jmethod_body( MethodPart m, String mname ) {
    // Argument list
    _sb.p(mname).p("( ");
    XType[] xargs = XType.xtypes(m._args);
    if( xargs!=null ) {
      for( int i = 0; i < xargs.length; i++ ) {
        Parameter p = m._args[i];
        xargs[i].p(_sb).p(' ').p(p._name).p(", ");
        define(p._name,xargs[i]);
      }
      _sb.unchar(2);
    }
    _sb.p(" ) ");
    // Body
    AST ast = ast(m);
    if( !(ast instanceof BlockAST) )
      ast = new BlockAST(ast);
    ast.jcode(_sb);
    _sb.nl();

    // Popped back to the original args
    assert (m._args==null ? 0 : m._args.length) == _nlocals;
    pop_locals(0);

    if( m._name2kid != null )
      for( Part part : m._name2kid.values() ) {
        if( part instanceof PropPart pp )
          XProp.make_class(_mod,_sb,pp);
        else if( part instanceof MMethodPart mmp ) {
          // Lambda expressions have been inlined
          if( mmp._name.equals("->") ) ;
          else {
            // Recursively dump name
            MethodPart meth = (MethodPart)mmp.child(mmp._name);
            jmethod(meth,mname+"$"+mmp._name);
          }
        } 
        else throw XEC.TODO();
      }
  }

  public void jmethod_body_inline( MethodPart meth, String mname ) {
    if( meth._name2kid != null ) throw XEC.TODO();
    AST ast = ast(meth);
    if( ast instanceof BlockAST blk ) {
      if( blk._kids.length>1 ) throw XEC.TODO();
      ast = blk._kids[0];
    }
    if( ast instanceof ReturnAST ret )
      ast = ret._kids[0];
    ast.jcode(_sb);
  }
  
  
  public AST ast( MethodPart m ) {
    // Build the AST from bytes
    _meth = m;
    _pool = new CPool(m._ast,m._cons); // Setup the constant pool parser
    AST ast = AST.parse(this);
    // Set types in every AST
    ast.type();
    // Do any trivial restructuring
    ast.do_rewrite();
    // Final AST ready to print as Java
    return ast;
  }

  
  int u8 () { return _pool.u8(); }  // Packed read
  int u31() { return _pool.u31(); } // Packed read
  long pack64() { return _pool.pack64(); }
  // Read an array of method constants
  Const[] consts() { return _pool.consts(); }
  Const[] sparse_consts(int len) { return _pool.sparse_consts(len); }
  // Read a single method constant, advancing parse pointer
  Const con() { return con(u31()); }
  // Read a single method constant
  Const con(int i) { return _meth._cons[i]; }

  // Read an array of AST kid terminals
  AST[] kids() { return _kids(u31(),0); }
  AST[] kids( int n ) { return _kids(n,0); }
  // Read an array of AST kid terminals, with a given bias (skipped elements are null).
  AST[] kids_bias( int b ) { return _kids(u31(),b); }
  
  private AST[] _kids( int n, int bias ) {
    if( n+bias==0 ) return null;
    AST[] kids = new AST[n+bias];
    for( int i=0; i<n; i++ )
      kids[i+bias] = AST.ast_term(this);
    return kids;
  }


  // --------------------------------------------------------------------------

  void define( String name, XType type ) {
    // Track active locals
    _locals.put(_nlocals  ,name);
    _ltypes.put(_nlocals++,type);
  }
    // Pop locals at end of scope
  void pop_locals(int n) {
    while( n < _nlocals ) {
      _ltypes.remove(  _nlocals);
      _locals.remove(--_nlocals);
    }
  }

  public static String java_class_name( String xname ) {
    return "J"+xname;
  }

  // After the basic mangle, dups are suffixed 1,2,3...
  String jname( String xname ) {
    String s = _mangle(xname);
    boolean unique = true;
    int max = 0;
    for( String old : _locals.values() ) {
      if( s.equals(old) ) unique = false;
      else if( old.startsWith(s) ) {
        int last = old.length();
        while( Character.isDigit(old.charAt(last-1)) ) last--;
        if( last == old.length() ) continue; // No trailing digits to confuse
        int num = Integer.parseInt(old.substring(last));
        max = Math.max(max,num);
      }
    }

    return unique ? s : s+(max+1);
  }

  // If the name is a valid java id, keep it.
  // If the name starts "loop#", use "i"
  // keep the valid prefix, and add $.
  private static String _mangle( String name ) {
    // Valid java name, just keep it
    // Valid except a keyword, add "$"
    if( SourceVersion.isIdentifier(name) )
      return SourceVersion.isKeyword(name) ? name+"$" : name;
    // Starts with "loop#", assume it is a generated loop variable for iterators
    if( name.startsWith("loop#") ) return "i";
    // Keep valid prefix and add "$"
    throw XEC.TODO();
  }


  // Produce a java value from a TCon
  private static final SB ASB = new SB();
  static public String value_tcon( Const tc ) {
    assert ASB.len()==0;
    // Caller is a switch, will encode special
    if( tc instanceof MatchAnyCon ) return null;
    _value_tcon(tc);
    String rez = ASB.toString();
    ASB.clear();
    return rez;
  }
  private static SB _value_tcon( Const tc ) {
    // Integer constants in XTC are Java Longs
    if( tc instanceof IntCon ic ) {
      if( ic._big != null ) throw XEC.TODO();
      return ASB.p(ic._x);
    }

    // Character constant
    if( tc instanceof CharCon cc )
      return ASB.p('\'').p((char)cc._ch).p('\'');

    // String constants
    if( tc instanceof StringCon sc )
      return ASB.p('"').escape(sc._str).p('"');
       
    // Literal constants
    if( tc instanceof LitCon lit )
      return ASB.p(lit._str);
    
    // Method constants
    if( tc instanceof MethodCon mcon )  {
      MethodPart meth = (MethodPart)mcon.part();
      // TODO: Assumes the method is in the local Java namespace
      // Lambda names "->" are inlined as Java lambdas
      String name = meth._name;
      if( !name.equals("->") && meth._par._par instanceof MethodPart pmeth )
        name = pmeth._name+"$"+meth._name;
      return ASB.p(name);
    }

    // Property constant.  Just the base name, and depending on usage
    // will be either console$get() or console$set(value).
    if( tc instanceof PropCon prop )
      return ASB.p(prop._name);

    // A class Type as a value
    if( tc instanceof ParamTCon ptc )
      return ASB.p(jtype(ptc,false));
    
    // Enums
    if( tc instanceof EnumCon econ ) {
      ClassPart clz = (ClassPart)econ.part();
      String sup_clz = clz._super._name;
      // Just use Java null
      if( sup_clz.equals("Nullable") )
        return ASB.p("null");
      // XTC Booleans rewrite as Java booleans
      if( sup_clz.equals("Boolean") ) 
        return ASB.p(clz._name.equals("False") ? "false" : "true");
      // Intercept Tuple enums
      if( sup_clz.equals("Mutability") ) {
        if( clz._super._par._name.equals("Tuple") ) {
          return ASB.p("Tuple.Mutability.").p(clz._name);          
        } else
          throw XEC.TODO();
      }
      // Use the enum name directly
      return ASB.p(sup_clz).p(".").p(clz._name);
    }

    // Singleton class constants (that are not enums)
    if( tc instanceof SingleCon con0 ) {
      if( con0.part() instanceof ModPart mod )
        return ASB.p(java_class_name(mod._name));
      if( con0.part() instanceof PropPart prop )
        return ASB.p(XProp.jname(prop)).p("$get()");
      throw XEC.TODO();
    }

    if( tc instanceof RangeCon rcon ) {
      String ext = rcon._xlo
        ? (rcon._xhi ? "EE" : "EI")
        : (rcon._xhi ? "IE" : "II");
      ASB.p("new Range").p(ext).p("(");
      _value_tcon(rcon._lo).p(",");
      _value_tcon(rcon._hi).p(")");
      return ASB;
    }
    
    // Array constants
    if( tc instanceof AryCon ac ) {
      assert ac.type() instanceof ImmutTCon; // Immutable array goes to static
      XType.Ary ary = (XType.Ary)XType.xtype(ac.type(),false);
      // new Ary<String>( "abc", "def");
      // new Arylong( 0, 1, 2 );
      // new Ary<Arylong>( new Arylong(0) )
      ary.p(ASB.p("new "));
      ASB.p("(  ");
      if( ac.cons()!=null )
        for( Const con : ac.cons() )
          _value_tcon( con ).p(", ");
      return ASB.unchar(2).p(")");
    }

    // Map constants
    if( tc instanceof MapCon mc ) {
      String type = jtype(mc._t,false);
      ASB.p("new ").p(type).p("() {{ ");
      for( int i=0; i<mc._keys.length; i++ ) {
        ASB.p("put(");
        _value_tcon( mc._keys[i] ).p(",");
        _value_tcon( mc._vals[i] ).p("); ");
      }
      ASB.p("}} ");
      return ASB;
    }

    // Special TermTCon
    if( tc instanceof TermTCon ttc ) {
      ClassPart clz = ttc.clz();
      if( clz._name.equals("Console") && clz._path._str.equals("ecstasy/io/Console.x") )
        return ASB.p("_container.console()");
      throw XEC.TODO();      
    }
  
    throw XEC.TODO();
  }

}
