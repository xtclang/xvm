package org.xvm.cc_explore.xclz;

import org.xvm.cc_explore.*;
import org.xvm.cc_explore.xrun.Container;
import org.xvm.cc_explore.xrun.NativeContainer;
import org.xvm.cc_explore.cons.*;
import org.xvm.cc_explore.util.*;

import java.lang.Character;
import java.util.HashMap;
import javax.lang.model.SourceVersion;
import java.lang.reflect.Constructor;

// Some kind of base class for a Java class that implements an XTC Module
public class XClzBuilder {
  public final ModPart _mod;
  public final SB _sb;
  XClz _xclz;            // Java class

  // Fields for emitting a Method Code
  public MethodPart _meth;      // Method whose code is being parsed
  private CPool _pool;          // Parser for code buffer
  final HashMap<String,String> _names; // Java namification
  final NonBlockingHashMapLong<String> _locals, _ltypes; // Virtual register numbers to java names
  int _nlocals;                 // Number of locals defined; popped when lexical scopes pop
  
  public XClzBuilder( ModPart mod ) {
    _mod = mod;
    _sb = new SB();
    _names = new HashMap<>();
    _locals = new NonBlockingHashMapLong<>();
    _ltypes = new NonBlockingHashMapLong<>();
  }

  // Convert a local name to the local index
  long name2idx( String name ) {
    for( long l : _locals.keySetLong() )
      if( _locals.get(l).equals(name) )
        return l;
    return -1;
  }

  
  // Let's start by assuming if we're here, we're inside the top-level
  // ecstasy package - otherwise we're nested instead the mirror for the
  // containing package.
  public XClz xclz() {
    assert _mod.child("ecstasy") instanceof PackagePart;

    // The Java class will extend XClz.
    // The Java class name will be the mangled module class-name.
    String java_class_name = java_class_name(_mod);
    jclass_body(java_class_name);
    System.out.println(_sb);
    
    try {
      Class<XClz> clz = XClzCompiler.compile("org.xvm.cc_explore.xclz."+java_class_name, _sb);
      Constructor<XClz> xcon = clz.getConstructor(Container.class);
      return xcon.newInstance(new NativeContainer());
    } catch( Exception ie ) {
      throw XEC.TODO();
    }
  }

  
  // Fill in the body of the matching java class
  private void jclass_body( String java_class_name ) {
    _sb.p("// Auto Generated by XEC from ").p(_mod._dir._str).p(_mod._path._str).nl().nl();
    _sb.p("package org.xvm.cc_explore.xclz;").nl().nl();
    _sb.p("import org.xvm.cc_explore.xrun.*;").nl();
    _sb.p("import static org.xvm.cc_explore.xrun.XRuntime.$t;").nl();
    _sb.nl();
    _sb.p("public class ").p(java_class_name).p(" extends XClz {").nl().ii();

    // Required constructor to inject the container
    _sb.ip("public ").p(java_class_name).p("( Container container ) { super(container); }").nl();
    
    // Look for a module init.  This will become the Java <clinit>
    MMethodPart mm = (MMethodPart)_mod.child("construct");
    MethodPart construct = (MethodPart)mm.child(mm._name);
    if( construct != null ) {
      assert _locals.isEmpty() && _nlocals==0; // No locals mapped yet
      assert construct._sibling==null;
      // Skip common empty constructor
      if( !construct.is_empty_function() ) {
        _sb.nl();
        _sb.ip("static {").nl();
        ast(construct).jcode(_sb );
        _sb.ip("}").nl().nl();
      }
    }

    // Output Java methods for all Module methods
    // TODO: Classes in a Module?
    for( Part part : _mod._name2kid.values() ) {
      if( part instanceof MMethodPart mmp ) {
        if( mmp._name.equals("construct") ) continue; // Already handled module constructor
        _sb.nl();
        MethodPart meth = (MethodPart)mmp.child(mmp._name);
        jmethod(meth);
      } else if( part instanceof PackagePart ) {
        // Self module is OK
      } else {
        throw XEC.TODO();
      }
    }

    // End the class body
    _sb.di().p("}").nl();
  }
  
  // Emit a Java string for this MethodPart.
  // Already _sb has the indent set.
  private void jmethod( MethodPart m ) {
    assert _locals.isEmpty() && _nlocals==0; // No locals mapped yet
    _sb.ip("public ");
    // Return type
    if( m._rets==null ) _sb.p("void ");
    else if( m._rets.length == 1 ) _sb.p(jtype(m._rets[0]._con,false)).p(' ');
    else throw XEC.TODO(); // Multi-returns will need much help
    // Argument list
    _sb.p(m._name).p("( ");
    if( m._args!=null ) {
      for( int i = 0; i < m._args.length; i++ ) {
        Parameter p = m._args[i];
        String type = jtype(p._con,false);
        _sb.p(type).p(' ').p(p._name).p(", ");
        define(p._name,type);
      }
      _sb.unchar(2);
    }
    _sb.p(" ) ");
    // Body    
    ast(m).jcode(_sb);
    _sb.nl();

    // Popped back to the original args
    assert (m._args==null ? 0 : m._args.length) == _nlocals;
    pop_locals(0);
  }

  AST ast( MethodPart m ) {
    // Build the AST from bytes
    _meth = m;
    _pool = new CPool(m._ast,m._cons); // Setup the constant pool parser
    AST ast = AST.parse(this);
    // Do any trivial restructuring
    ast = ast.do_rewrite();
    return ast;
  }

  
  int u8 () { return _pool.u8(); }  // Packed read
  int u31() { return _pool.u31(); } // Packed read
  long pack64() { return _pool.pack64(); }
  String utf8() { return _pool.utf8(); }
  // Read an array of method constants
  Const[] consts() { return _pool.consts(); }
  // Read a single method constant, advancing parse pointer
  Const con() { return con(u31()); }
  // Read a single method constant
  Const con(int i) { return _meth._cons[i]; }

  // Read an array of AST kid terminals
  AST[] kids() { return _kids(u31(),0); }
  AST[] kids( int n ) { return _kids(n,0); }
  // Read an array of AST kid terminals, with a given bias (skipped elements are null).
  AST[] kids_bias( int b ) { return _kids(u31(),b); }
  
  private AST[] _kids( int n, int bias ) {
    if( n+bias==0 ) return null;
    AST[] kids = new AST[n+bias];
    for( int i=0; i<n; i++ )
      kids[i+bias] = AST.ast_term(this);
    return kids;
  }


  // --------------------------------------------------------------------------

  void define( String name, String type ) {
    // Track active locals
    _locals.put(_nlocals  ,name);
    _ltypes.put(_nlocals++,type);
  }
    // Pop locals at end of scope
  void pop_locals(int n) {
    while( n < _nlocals )
      _locals.remove(--_nlocals);
  }

  static String java_class_name( ModPart mod ) {
    return "J"+mod._name;
  }

  // After the basic mangle, dups are suffixed 1,2,3...
  String jname( String xname ) {
    String s = _mangle(xname);
    boolean unique = true;
    int max = 0;
    for( String old : _locals.values() ) {
      if( s.equals(old) ) unique = false;
      else if( old.startsWith(s) ) {
        int last = old.length();
        while( Character.isDigit(old.charAt(last-1)) ) last--;
        if( last == old.length() ) continue; // No trailing digits to confuse
        int num = Integer.parseInt(old.substring(last));
        max = Math.max(max,num);
      }
    }

    return unique ? s : s+(max+1);
  }

  // If the name is a valid java id, keep it.
  // If the name starts "loop#", use "i"
  // keep the valid prefix, and add $.
  private static String _mangle( String name ) {
    // Valid java name, just keep it
    // Valid except a keyword, add "$"
    if( SourceVersion.isIdentifier(name) )
      return SourceVersion.isKeyword(name) ? name+"$" : name;
    // Starts with "loop#", assume it is a generated loop variable for iterators
    if( name.startsWith("loop#") ) return "i";
    // Keep valid prefix and add "$"
    throw XEC.TODO();
  }


  // A set of common XTC classes, and their Java replacements.
  // These are NOT parameterized.
  static final HashMap<String,String> XJMAP = new HashMap<>() {{
      put("Console+ecstasy/io/Console.x","Console");
      put("Int64+ecstasy/numbers/Int64.x","long");
      put("Boolean+ecstasy/Boolean.x","boolean");
      put("StringBuffer+ecstasy/text/StringBuffer.x","StringBuffer");
    }};
  
  // Produce a java type from a method constant
  String jtype_methcon() { return jtype( con(), false ); }
  // Produce a java type from a TermTCon
  static String jtype( Const tc, boolean boxed ) {
    if( tc instanceof TermTCon ttc ) {
      ClassPart clz = (ClassPart)ttc.part();
      String key = clz._name + "+" + clz._path._str;
      String val = XJMAP.get(key);
      if( val!=null )
        return boxed ? val.substring(0,1).toUpperCase() + val.substring(1) : val;
      throw XEC.TODO();
    }
    if( tc instanceof ParamTCon ptc ) {
      String telem = jtype(ptc._parms[0],true);
      ClassPart clz = ((ClzCon)ptc._con).clz();
      if( clz._name.equals("Array") && clz._path._str.equals("ecstasy/collections/Array.x") ) {
        if( telem.equals("Long") )  return "AryI64"; // Java ArrayList specialized to int64
        return "Ary<"+telem+">"; // Shortcut class
      }
      if( clz._name.equals("Range") && clz._path._str.equals("ecstasy/Range.x") ) {
        if( telem.equals("Long") ) return "Range"; // Shortcut class
        else throw XEC.TODO();
      }
      if( clz._name.equals("List") && clz._path._str.equals("ecstasy/collections/List.x") )
        return "Ary<"+telem+">"; // Shortcut class
      if( clz._name.equals("Tuple") && clz._path._str.equals("ecstasy/collections/Tuple.x") ) {
        if( ptc._parms.length==1 )  // Tuple of length 1 ?
          return "Ary<"+telem+">"; // Shortcut class
        throw XEC.TODO();
      }
      if( clz._name.equals("Function") && clz._path._str.equals("ecstasy/reflect/Function.x") )
        // TODO: Gonna need more type info that this
        return "XFunc";
         
      throw XEC.TODO();
    }
    if( tc instanceof ImmutTCon itc ) 
      return jtype(itc.icon(),boxed); // Ignore immutable for now
    
    throw XEC.TODO();
  }  

  // Produce a java value from a TCon
  private static final SB ASB = new SB();
  static public String value_tcon( TCon tc ) {
    assert ASB.len()==0;
    value_tcon(ASB,tc);
    String rez = ASB.toString();
    ASB.clear();
    return rez;
  }
  private static SB value_tcon( SB asb, TCon tc ) {
    // Integer constants
    if( tc instanceof IntCon ic ) {
      if( ic._big != null ) throw XEC.TODO();
      ASB.p(ic._x);
      return (int)ic._x == ic._x ? ASB : ASB.p('L');
    }
    
    // String constants
    if( tc instanceof StringCon sc )
      return ASB.p('"').p(sc._str).p('"');
    
    // Array constants
    if( tc instanceof AryCon ac ) {
      assert ac.type() instanceof ImmutTCon; // Immutable array goes to static
      String type = jtype(ac.type(),false);
      int lastx = type.length()-1;
      char ch = type.charAt(lastx);
      
      if( ch!=']' ) { // e.g. AryI64 or Ary<AryI64>
        // Generic Ary flavors.
        int genx = type.indexOf('<');
        String  genclz = ch=='>' ? type.substring(genx+1,lastx) : null;
        String baseclz = ch=='>' ? type.substring(0,genx) : type;        
        ASB.p("new ").p(baseclz).p("(");
        if( genclz != null ) ASB.p(genclz).p(".class");
        ASB.p(")");
        
        if( ac.cons()!=null )
          for( Const con : ac.cons() )
            value_tcon( ASB.p(".add("), (TCon)con ).p(")");
        return ASB;
        
      } else {
        // Standard arrays, e.g. long[]
        ASB.p("new ").p(type).p("[]");
        if( ac.cons()!=null ) {
          ASB.p("{ ");
          for( Const con : ac.cons() )
            value_tcon( ASB, (TCon)con ).p(", ");
          ASB.p("}");
        }
        return ASB;
      }
    }
    
    // Booleans
    if( tc instanceof EnumCon econ ) {
      ClassPart clz = (ClassPart)econ.part();
      if( !clz._super._name.equals("Boolean") ) throw XEC.TODO();
      return ASB.p(clz._name.equals("False") ? "false" : "true");
    }
    
    // Literal constants
    if( tc instanceof LitCon lit )
      return ASB.p(lit._str);
    
    // Method constants
    if( tc instanceof MethodCon mcon )  {
      MethodPart meth = (MethodPart)mcon.part();
      // TODO: Assumes the method is in the local Java namespace
      String name = meth._name;
      return ASB.p(name);
    }

    // Singleton class constants
    if( tc instanceof SingleCon con0 ) {
      return ASB.p(java_class_name((ModPart)con0.part()));
    }

    // Property constant.  Just the base name, and depending on usage
    // will be either console$get() or console$set(value).
    if( tc instanceof PropCon prop ) {
      return ASB.p(prop._name);
    }
    
    throw XEC.TODO();
  }

  // Produce a java value from a TermTCon
  static String jvalue_ttcon( TermTCon ttc ) {
    ClassPart clz = ttc.clz();
    if( clz._name.equals("Console") && clz._path._str.equals("ecstasy/io/Console.x") )
      return "_container.console()";
    throw XEC.TODO();
  }  
}
