/**
 * A `NonceManager` generates and validates nonces, and supports an automatic expiry.
 */
service NonceManager(Duration? expiry = Null) {

    // ----- properties ----------------------------------------------------------------------------

    private static @Inject Clock clock;

    private @Inject Random rnd;

    /**
     * The duration that a nonce is valid from the point in time that it was generated.
     */
    public/private @Final Duration? expiry;

    /**
     * Nodes stored by nonce value.
     */
    private HashMap<Int, Node> nodes = new HashMap();

    /**
     * Head of linked list of nodes, iff nonces expire.
     */
    private Node? oldest;

    /**
     * Tail of linked list of nodes, iff nonces expire.
     */
    private Node? newest;

    /**
     * Generator count.
     */
    private Int count;

    // ----- API -----------------------------------------------------------------------------------

    /**
     * Generate a nonce value.
     *
     * @return the nonce value
     */
    Int generate() {
        // generate a new nonce value
        Int nonce;
        do {
            // the value is a random 64-bit signed int, but we disallow negative values
            nonce = rnd.int(MaxValue);
        } while (nodes.contains(nonce));

        // periodically clean up any expired nonces
        if (++count & 0x3FF == 0) {
            clean();
        }

        Node node = new Node(nonce);
        nodes[nonce] = node;
        if (expiry != Null) {
            node.prev    = newest;
            newest?.next = node;
            newest       = node;
            oldest     ?:= node;
        }

        return nonce;
    }

    /**
     * Validate a previously generated nonce value.
     *
     * @param nonce  the nonce value
     *
     * @return `True` iff the nonce value was generated by this `NonceManager`, has not already been
     *         validated, and has not already expired
     */
    Boolean validate(Int nonce) {
        // get rid of any expired nonces (which makes validation simpler)
        clean();

        if (Node node := nodes.get(nonce), !node.dead) {
            kill(node);
            return True;
        }

        return False;
    }

    /**
     * Remove (invalidate) all previously generated nonce values.
     */
    void reset() {
        nodes.clear();
        oldest = Null;
        newest = Null;
    }

    // ----- internal ------------------------------------------------------------------------------

    private static class Node(Int nonce) {
        Node?   next    = Null;
        Node?   prev    = Null;
        Boolean dead    = False;
        Time    created = clock.now;
    }

    private void clean() {
        Node? node = oldest;
        if (node != Null) {
            Time cutoff = clock.now - expiry ?: assert;
            while (node != Null && node.created < cutoff) {
                if (!node.dead) {
                    // we could use kill() here, but it does an awful lot of unnecessary
                    // house-cleaning considering we're throwing a bunch of nodes away
                    nodes.remove(node.nonce);
                    node.dead = True;
                }
                node = node.next;
            }

            // this is the deferred house-cleaning from above
            oldest = node;
            if (node == Null) {
                newest = Null;
                assert nodes.empty;
            } else {
                node.prev = Null;
            }
        }
    }

    private void kill(Node node) {
        if (!node.dead) {
            node.dead = True;
            nodes.remove(node.nonce);
            if (&oldest == &node) {
                oldest = node.next;
            }
            if (&newest == &node) {
                newest = node.prev;
            }
            node.prev?.next = node.next;
            node.next?.prev = node.prev;
        }
    }
}