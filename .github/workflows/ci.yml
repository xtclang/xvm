#
# GitHub runner workflow for building, verifying and testing the XVM repo.
#
name: XVM Verification and Package Updates

on:
  push:
  workflow_dispatch:
    inputs:
      always_publish_snapshot:
        description: 'Always publish snapshot regardless of branch'
        type: boolean
        required: false
        default: false
      always_build_docker_image:
        description: 'Always build Docker images regardless of branch'
        type: boolean
        required: false
        default: false
      single_platform:
        description: 'Run only single platform (ubuntu-latest, windows-latest, or full matrix)'
        type: choice
        required: false
        default: 'full'
        options:
          - 'full'
          - 'ubuntu-latest'
          - 'windows-latest'
      extra_gradle_options:
        description: 'Extra Gradle options to pass to the build'
        required: false
      run_manual_tests:
        description: 'Run manual tests'
        type: boolean
        required: false
        default: true
      run_manual_tests_parallel:
        description: 'Run manual tests in parallel mode'
        type: boolean
        required: false
        default: true

env:
  # TODO: Default should be disabled; we only want to be bothered by tagging and publishing for the master branch.
  always_publish_snapshot: ${{ github.event.inputs.always_publish_snapshot == 'true' }}

  # Add manual tests as an included build to the composite build configuration, and also build them.
  ORG_GRADLE_PROJECT_includeBuildManualTests: true
  ORG_GRADLE_PROJECT_includeBuildAttachManualTests: true
  ORG_GRADLE_PROJECT_xtcPluginOverrideVerboseLogging: true

  # Add sanity checks that the javatools fatjar contains appropriate classes and dependencies
  ORG_XTCLANG_JAVATOOLS_SANITY_CHECK_JAR: true

  # Secrets (TODO: Verify plugin portal and maven central/sonatype credentials)
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GRADLE_PUBLISH_KEY: ${{ secrets.ORG_XTCLANG_GRADLE_PLUGIN_PORTAL_PUBLISH_KEY }}
  GRADLE_PUBLISH_SECRET: ${{ secrets.ORG_XTCLANG_GRADLE_PLUGIN_PORTAL_PUBLISH_SECRET }}
  GPG_SIGNING_KEY: ${{ secrets.ORG_XTCLANG_GPG_SIGNING_KEY }}
  GPG_SIGNING_PASSWORD: ${{ secrets.ORG_XTCLANG_GPG_SIGNING_PASSWORD }}
  MAVEN_CENTRAL_USERNAME: ${{ secrets.ORG_XTCLANG_MAVEN_CENTRAL_USERNAME }}
  MAVEN_CENTRAL_PASSWORD: ${{ secrets.ORG_XTCLANG_MAVEN_CENTRAL_PASSWORD }}

  gradle_options: "-Dorg.gradle.caching.debug=false -Dorg.gradle.vfs.verbose=false --stacktrace --warning-mode=all --console=plain ${{ inputs.extra_gradle_options }}"
  
  # JVM configuration for container environments
  java_opts: "-XX:+UseContainerSupport"

  # Optional flags to control manual tests
  run_manual_tests: ${{ github.event.inputs.run_manual_tests != 'false' }}
  run_manual_tests_parallel: ${{ github.event.inputs.run_manual_tests_parallel != 'false' }}

  java_version: 21
  java_distribution: temurin
  gradle_version: 8.14.2

  # Docker build variables (DRY approach)
  GH_COMMIT: ${{ github.sha }}
  GH_BRANCH: ${{ github.ref_name }}
  DOCKER_BASE_IMAGE: ${{ github.ref_name == 'master' && 'ghcr.io/xtclang/xvm' || format('ghcr.io/xtclang/xvm-{0}', github.ref_name) }}
  
  # Gradle cache inspection function (DRY approach)
  GRADLE_CACHE_INSPECT: |
    inspect_gradle_cache() {
      local label="${1:-}"
      local gradle_home="${GRADLE_USER_HOME:-$HOME/.gradle}"
      echo "üîç Gradle Cache Inspection${label:+ ($label)}:"
      echo "  Cache location: $gradle_home"
      if [ -d "$gradle_home" ]; then
        echo "  Cache exists: ‚úÖ"
        local total_size=$(du -sh "$gradle_home" 2>/dev/null | cut -f1 || echo "unknown")
        local total_bytes=$(du -sb "$gradle_home" 2>/dev/null | cut -f1 || echo "unknown")
        echo "  Cache size: $total_size ($total_bytes bytes)"
        for dir in caches wrapper build-cache; do
          if [ -d "$gradle_home/$dir" ]; then
            local dir_size=$(du -sh "$gradle_home/$dir" 2>/dev/null | cut -f1 || echo "unknown")
            echo "    $dir: $dir_size"
          fi
        done
      else
        echo "  Cache exists: ‚ùå"
      fi
    }

  # Build environment and build workflow debug flags.
  # ACTIONS_RUNNER_DEBUG: true
  # ACTIONS_STEP_DEBUG: true
  GRADLE_BUILD_ACTION_CACHE_DEBUG_ENABLED: true

# Concurrency settings: group by workflow and ref, cancel intermediate builds, but only if it's a pull request build.
concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: ${{ github.ref != 'refs/heads/master' }}

jobs:
  build-verify:

    strategy:
      matrix:
        os: ${{ github.event.inputs.single_platform == 'ubuntu-latest' && fromJSON('["ubuntu-latest"]') || github.event.inputs.single_platform == 'windows-latest' && fromJSON('["windows-latest"]') || fromJSON('["ubuntu-latest", "windows-latest"]') }}

    runs-on: ${{ matrix.os }}

    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4
        with:
          show-progress: true

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.java_distribution }}
          java-version: ${{ env.java_version }}

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-disabled: false
          cache-read-only: false
          gradle-version: ${{ env.gradle_version }}

      - name: Validate Gradle Wrapper
        uses: gradle/actions/wrapper-validation@v4

      - name: Dump environment info
        shell: bash
        run: |
          echo "*** Branch (github.ref)    : ${{ github.ref }}"
          echo "*** Commit (github.sha)    : ${{ github.sha }}"
          echo "*** Runner OS              : ${{ runner.os }}"
          echo "*** Workflow dispatch inputs:"
          echo "    always_publish_snapshot: '${{ github.event.inputs.always_publish_snapshot }}'"
          echo "    always_build_docker_image: '${{ github.event.inputs.always_build_docker_image }}'"
          echo "    run_manual_tests: '${{ github.event.inputs.run_manual_tests }}'"
          echo "    run_manual_tests_parallel: '${{ github.event.inputs.run_manual_tests_parallel }}'"
          echo "    extra_gradle_options: '${{ github.event.inputs.extra_gradle_options }}'"
          echo "*** Environment variables:"
          echo "    always_publish_snapshot: '${{ env.always_publish_snapshot }}'"
          echo "    run_manual_tests: '${{ env.run_manual_tests }}'"
          echo "    run_manual_tests_parallel: '${{ env.run_manual_tests_parallel }}'"
          echo "*** Java system properties :" 
          java -XshowSettings:properties --version

      - name: Build the XDK and create a distribution layout
        shell: bash
        env:
          JAVA_OPTS: ${{ env.java_opts }}
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          cwd_path=$(pwd)
          echo "Executing Gradle 'installDist' task from path: '$cwd_path'"
          echo "Skipping 'gradle clean' - fresh runner + cache integrity guaranteed"
          ls -la build/ 2>/dev/null && echo "WARNING: build/ directory exists on fresh runner!" || echo "‚úÖ Confirmed: No previous build outputs"
          
          echo "üîß JVM Configuration:"
          echo "  JAVA_OPTS: $JAVA_OPTS"
          
          # Print JVM flags for debugging  
          echo "üîç JVM Flag Information:"
          java -XX:+UseContainerSupport -XX:+PrintFlagsFinal -version 2>&1 | head -10 || echo "  Flag printing failed (non-fatal)"
          
          inspect_gradle_cache "before installDist"
          ./gradlew ${{ env.gradle_options }} installDist 

      - name: Build a machine specific XDK installation with native launchers, test run launchers on native platform
        shell: bash
        env:
          JAVA_OPTS: ${{ env.java_opts }}
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before native launcher build"
          ./gradlew ${{ env.gradle_options }} xdk:installWithLaunchersDist
          xcc_path=$(find xdk/build/install/ -name xcc)
          xec_path=$(find xdk/build/install/ -name xec)
          echo "Location of native launcher (xcc): $xcc_path"
          echo "Location of native launcher (xec): $xec_path"
          echo "*** Testing native launchers, verifying their binary format and that they run on this platform..."
          xcc_file=$(file $xcc_path)
          xec_file=$(file $xec_path)
          xcc_version=$($xcc_path --version)
          xec_version=$($xec_path --version)
          echo "    xcc:"
          echo "        file   : $xcc_file"
          echo "        version: $xcc_version"
          echo "    xec:"
          echo "        file   : $xec_file"
          echo "        version: $xec_version"
          echo "*** Native launchers work."

      - name: Manual tests
        if: ${{ env.run_manual_tests == 'true' }}
        timeout-minutes: 10
        shell: bash
        env:
          JAVA_OPTS: ${{ env.java_opts }}
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before manual tests"
          
          # Always run basic manual tests
          ./gradlew ${{ env.gradle_options }} manualTests:runXtc
          ./gradlew ${{ env.gradle_options }} manualTests:runOne -PtestName=TestMisc
          ./gradlew ${{ env.gradle_options }} manualTests:runTwoTestsInSequence
          
          # Run parallel or sequential tests based on setting
          MANUAL_TASK=$( [ "${{ env.run_manual_tests_parallel }}" = "true" ] && echo "runParallel" || echo "runSequential" )
          ./gradlew ${{ env.gradle_options }} manualTests:$MANUAL_TASK

      - name: Upload build artifacts
        if: ${{ success() && matrix.os == 'ubuntu-latest' }}
        uses: actions/upload-artifact@v4
        with:
          name: xdk-distribution
          path: |
            xdk/build/distributions/
            xdk/build/install/
          retention-days: 1

  publish-snapshot:
    name: Publish to GitHub packages iff snapshot + non-redundant build platform + branch is master
    # Only run if ALL build-verify matrix jobs succeed (both ubuntu-latest and windows-latest)
    needs: build-verify
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_publish_snapshot == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      # Check out current repository
      - name: Fetch Sources
        uses: actions/checkout@v4

      # Set up Java environment for the next steps
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.java_distribution }}
          java-version: ${{ env.java_version }}

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-disabled: false
          cache-read-only: true  # Read-only since build-verify already populated cache
          gradle-version: ${{ env.gradle_version }}

      - name: Debug publish conditions and verify all tests passed
        run: |
          echo "üêõ Debug publish job conditions:"
          echo "  always_publish_snapshot input: '${{ github.event.inputs.always_publish_snapshot }}'"
          echo "  github.ref: '${{ github.ref }}'"
          echo "  Condition should be: always_publish_snapshot == 'true' OR github.ref == 'refs/heads/master'"
          echo "  This job should NOT run on non-master branch without explicit flag!"
          echo ""
          echo "‚úÖ All build-verify matrix jobs (Ubuntu + Windows) completed successfully"
          echo "‚úÖ All tests passed - proceeding with publication"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: xdk-distribution
          path: .

      - name: Dump environment info
        shell: bash
        run: |
          echo "*** Branch (github.ref)    : ${{ github.ref }}"
          echo "*** Commit (github.sha)    : ${{ github.sha }}"
          echo "*** Runner OS              : ${{ runner.os }}"
          echo "*** Workflow inputs:"
          echo "    always_publish_snapshot (raw): '${{ github.event.inputs.always_publish_snapshot }}'"
          echo "    always_publish_snapshot (env): '${{ env.always_publish_snapshot }}'"
          echo "*** Java system properties :" 
          java -XshowSettings:properties --version

      - name: Create or Update Snapshot (if pushed to 'master', or env.always_publish_snapshot is true)
        if: ${{ (github.event.inputs.always_publish_snapshot == 'true') || (github.ref == 'refs/heads/master') }}
        shell: bash
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before publishing (reused from build-verify)"
          
          echo "Reusing build cache from build-verify job..."
          ./gradlew ${{ env.gradle_options }} xdk:ensureTags -PsnapshotOnly=true
          ./gradlew ${{ env.gradle_options }} publishRemote -PsnapshotOnly=true

  docker-build:
    name: Build and push Docker images
    needs: build-verify
    runs-on: ${{ matrix.runner }}
    if: ${{ success() && ((github.event.inputs.always_build_docker_image) || (github.ref == 'refs/heads/master')) }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            arch: amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            arch: arm64
            runner: ubuntu-24.04-arm
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      # Set up Java and Gradle to warm cache for Docker build
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.java_distribution }}
          java-version: ${{ env.java_version }}

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
        with:
          cache-disabled: false
          cache-read-only: true  # Read-only since build-verify already populated cache
          gradle-version: ${{ env.gradle_version }}

      # Note: Dockerfile is self-contained and downloads source itself
      # But now Docker build can benefit from Gradle cache via GitHub Actions cache

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image (${{ matrix.arch }})
        shell: bash
        working-directory: docker
        run: |
          echo "Building and pushing ${{ matrix.arch }} Docker image on native hardware..."
          
          # Setup variables
          VERSION=$(cat ../VERSION | tr -d '\n\r ')
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          # Sanitize branch name once (replace illegal Docker tag characters with underscores)
          BRANCH_SANITIZED=$(echo "${GH_BRANCH}" | sed 's/[^a-zA-Z0-9._-]/_/g')
          echo "Using sanitized branch name: ${BRANCH_SANITIZED} (from: ${GH_BRANCH})"
          
          # Build tag list for this architecture
          TAGS=(
            "${DOCKER_BASE_IMAGE}:latest-${{ matrix.arch }}"
            "${DOCKER_BASE_IMAGE}:${VERSION}-${{ matrix.arch }}"
            "${DOCKER_BASE_IMAGE}:${GH_COMMIT}-${{ matrix.arch }}"
            "${DOCKER_BASE_IMAGE}:${BRANCH_SANITIZED}-${{ matrix.arch }}"
          )
          
          # Convert to --tag arguments
          TAG_ARGS=""
          for tag in "${TAGS[@]}"; do
            TAG_ARGS="${TAG_ARGS} --tag ${tag}"
          done
          
          # Cache inspection
          ${{ env.GRADLE_CACHE_INSPECT }}
          inspect_gradle_cache "host cache before Docker build"
          
          # Build and push with architecture-specific cache 
          docker buildx build \
            --platform ${{ matrix.platform }} \
            ${TAG_ARGS} \
            --build-arg GH_BRANCH=${GH_BRANCH} \
            --build-arg GH_COMMIT=${GH_COMMIT} \
            --label org.opencontainers.image.created=${BUILD_DATE} \
            --label org.opencontainers.image.revision=${GITHUB_SHA} \
            --label org.opencontainers.image.version=${VERSION} \
            --label org.opencontainers.image.source=https://github.com/xtclang/xvm/tree/${GH_BRANCH} \
            --cache-from type=gha,scope=${{ matrix.arch }} \
            --cache-to type=gha,mode=max,scope=${{ matrix.arch }} \
            --provenance=false \
            --output type=registry \
            .

  docker-manifest:
    name: Create multi-platform manifest
    needs: docker-build
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image) || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-platform manifests
        shell: bash
        run: |
          echo "Building and pushing multi-platform Docker images..."
          
          # Setup common variables
          VERSION=$(grep -E '^version\s*=' gradle.properties | cut -d'=' -f2 | tr -d ' ')
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          # Use the correct base image for this branch (same as docker-build jobs)
          BASE_IMAGE="${DOCKER_BASE_IMAGE}"
          
          # Sanitize branch name once (replace illegal Docker tag characters with underscores)
          BRANCH_SANITIZED=$(echo "${GH_BRANCH}" | sed 's/[^a-zA-Z0-9._-]/_/g')
          echo "Using sanitized branch name: ${BRANCH_SANITIZED} (from: ${GH_BRANCH})"
          
          # Build common tag list
          TAGS=(
            "${BASE_IMAGE}:latest"
            "${BASE_IMAGE}:${VERSION}" 
            "${BASE_IMAGE}:${GITHUB_SHA}"
            "${BASE_IMAGE}:${BRANCH_SANITIZED}"
          )
          
          # Convert array to --tag arguments
          TAG_ARGS=""
          for tag in "${TAGS[@]}"; do
            TAG_ARGS="${TAG_ARGS} --tag ${tag}"
          done
          
          # Build and push multi-platform image
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            ${TAG_ARGS} \
            --build-arg GH_BRANCH=${GH_BRANCH} \
            --build-arg GH_COMMIT=${GITHUB_SHA} \
            --build-arg BUILD_DATE=${BUILD_DATE} \
            --build-arg VCS_REF=${GITHUB_SHA} \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --push \
            docker/

  docker-test:
    name: Test Docker image functionality
    needs: docker-manifest
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image) || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Test Docker image with EchoTest arguments
        shell: bash
        run: |
          echo "Testing Docker image functionality with EchoTest..."
          
          IMAGE="${{ env.DOCKER_BASE_IMAGE }}:latest"
          
          # Test functions with early exits
          test_no_args() {
            echo "üß™ Testing EchoTest with no arguments..."
            local output=$(docker run --rm ${IMAGE} xec EchoTest 2>&1)
            echo "Output: $output"
            
            if ! echo "$output" | grep -q "EchoTest invoked with 0 arguments\."; then
              echo "‚ùå No arguments test failed"
              exit 1
            fi
            echo "‚úÖ No arguments test passed"
          }
          
          test_single_arg() {
            echo "üß™ Testing EchoTest with single argument..."
            local output=$(docker run --rm ${IMAGE} xec EchoTest "hello" 2>&1)
            echo "Output: $output"
            
            if ! echo "$output" | grep -q "EchoTest invoked with 1 arguments:"; then
              echo "‚ùå Single argument test failed - wrong count"
              exit 1
            fi
            
            if ! echo "$output" | grep -q '\[1\]="hello"'; then
              echo "‚ùå Single argument test failed - wrong content"
              exit 1
            fi
            echo "‚úÖ Single argument test passed"
          }
          
          test_multiple_args() {
            echo "üß™ Testing EchoTest with multiple arguments..."
            local output=$(docker run --rm ${IMAGE} xec EchoTest "arg1" "arg with spaces" "arg3" 2>&1)
            echo "Output: $output"
            
            if ! echo "$output" | grep -q "EchoTest invoked with 3 arguments:"; then
              echo "‚ùå Multiple arguments test failed - wrong count"
              exit 1
            fi
            
            if ! echo "$output" | grep -q '\[1\]="arg1"'; then
              echo "‚ùå Multiple arguments test failed - missing arg1"
              exit 1
            fi
            
            if ! echo "$output" | grep -q '\[2\]="arg with spaces"'; then
              echo "‚ùå Multiple arguments test failed - missing spaced arg"
              exit 1
            fi
            
            if ! echo "$output" | grep -q '\[3\]="arg3"'; then
              echo "‚ùå Multiple arguments test failed - missing arg3"
              exit 1
            fi
            echo "‚úÖ Multiple arguments test passed"
          }
          
          # Run all tests with early exits
          test_no_args
          test_single_arg  
          test_multiple_args
          
          echo "üéâ All Docker image tests passed successfully!"

  docker-cleanup:
    name: Clean up old Docker package versions
    needs: docker-test
    runs-on: ubuntu-latest
    if: ${{ success() && github.ref == 'refs/heads/master' }}
    steps:
      - name: Clean up old container versions
        uses: snok/container-retention-policy@v3
        with:
          image-names: xvm
          cut-off: 4 weeks ago UTC
          keep-n-most-recent: 5
          account-type: org
          org-name: xtclang
          token: ${{ secrets.GITHUB_TOKEN }}
