#
# GitHub runner workflow for building, verifying and testing the XVM repo.
#
name: XVM Verification and Package Updates

# Grant additional permissions needed for Docker package management  
permissions:
  contents: write
  packages: write
  actions: read
  # Note: GitHub Actions doesn't support packages: delete in permissions
  # Docker cleanup uses PACKAGE_DELETE_TOKEN (org PAT) if available, otherwise shows warnings

on:
  push:
  workflow_dispatch:
    inputs:
      always_publish_snapshot:
        description: 'Always publish snapshot regardless of branch'
        type: boolean
        required: false
        default: false
      always_build_docker_image:
        description: 'Always build Docker images regardless of branch'
        type: boolean
        required: false
        default: false
      always_clean_docker:
        description: 'Always run Docker cleanup regardless of branch'
        type: boolean
        required: false
        default: false
      single_platform:
        description: 'Run only single platform (ubuntu-latest, windows-latest, or full matrix)'
        type: choice
        required: false
        default: 'full'
        options:
          - 'full'
          - 'ubuntu-latest'
          - 'windows-latest'
      extra_gradle_options:
        description: 'Extra Gradle options to pass to the build'
        required: false
      run_manual_tests:
        description: 'Run manual tests'
        type: boolean
        required: false
        default: true
      run_manual_tests_parallel:
        description: 'Run manual tests in parallel mode'
        type: boolean
        required: false
        default: true

env:
  # TODO: Default should be disabled; we only want to be bothered by tagging and publishing for the master branch.
  always_publish_snapshot: ${{ github.event.inputs.always_publish_snapshot == 'true' }}

  # Add manual tests as an included build to the composite build configuration, and also build them.
  ORG_GRADLE_PROJECT_includeBuildManualTests: true
  ORG_GRADLE_PROJECT_includeBuildAttachManualTests: true
  ORG_GRADLE_PROJECT_xtcPluginOverrideVerboseLogging: true

  # Add sanity checks that the javatools fatjar contains appropriate classes and dependencies
  ORG_XTCLANG_JAVATOOLS_SANITY_CHECK_JAR: true

  # Secrets (TODO: Verify plugin portal and maven central/sonatype credentials)
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GRADLE_PUBLISH_KEY: ${{ secrets.ORG_XTCLANG_GRADLE_PLUGIN_PORTAL_PUBLISH_KEY }}
  GRADLE_PUBLISH_SECRET: ${{ secrets.ORG_XTCLANG_GRADLE_PLUGIN_PORTAL_PUBLISH_SECRET }}
  GPG_SIGNING_KEY: ${{ secrets.ORG_XTCLANG_GPG_SIGNING_KEY }}
  GPG_SIGNING_PASSWORD: ${{ secrets.ORG_XTCLANG_GPG_SIGNING_PASSWORD }}
  MAVEN_CENTRAL_USERNAME: ${{ secrets.ORG_XTCLANG_MAVEN_CENTRAL_USERNAME }}
  MAVEN_CENTRAL_PASSWORD: ${{ secrets.ORG_XTCLANG_MAVEN_CENTRAL_PASSWORD }}

  gradle_options: "-Dorg.gradle.caching.debug=false -Dorg.gradle.vfs.verbose=false --stacktrace --warning-mode=all --console=plain ${{ inputs.extra_gradle_options }}"

  # Optional flags to control manual tests
  run_manual_tests: ${{ github.event.inputs.run_manual_tests != 'false' }}
  run_manual_tests_parallel: ${{ github.event.inputs.run_manual_tests_parallel != 'false' }}

  java_version: 21
  java_distribution: temurin
  gradle_version: 8.14.2

  # Docker build variables - computed once, used everywhere
  GH_COMMIT: ${{ github.sha }}
  GH_BRANCH: ${{ github.ref_name }}
  DOCKER_BASE_IMAGE: ghcr.io/xtclang/xvm

  # Gradle cache inspection function
  GRADLE_CACHE_INSPECT: |
    inspect_gradle_cache() {
      local label="${1:-}"
      local gradle_home="${GRADLE_USER_HOME:-$HOME/.gradle}"
      echo "üîç Gradle Cache Inspection${label:+ ($label)}:"
      echo "  Cache location: $gradle_home"
      if [ -d "$gradle_home" ]; then
        echo "  Cache exists: ‚úÖ"
        local total_size=$(du -sh "$gradle_home" 2>/dev/null | cut -f1 || echo "unknown")
        local total_bytes=$(du -sb "$gradle_home" 2>/dev/null | cut -f1 || echo "unknown")
        echo "  Cache size: $total_size ($total_bytes bytes)"
        for dir in caches wrapper build-cache; do
          if [ -d "$gradle_home/$dir" ]; then
            local dir_size=$(du -sh "$gradle_home/$dir" 2>/dev/null | cut -f1 || echo "unknown")
            echo "    $dir: $dir_size"
          fi
        done
      else
        echo "  Cache exists: ‚ùå"
      fi
    }

  # Build environment and build workflow debug flags.
  # ACTIONS_RUNNER_DEBUG: true
  # ACTIONS_STEP_DEBUG: true
  GRADLE_BUILD_ACTION_CACHE_DEBUG_ENABLED: true

# Concurrency settings: group by workflow and ref, cancel intermediate builds, but only if it's a pull request build.
concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: ${{ github.ref != 'refs/heads/master' }}

jobs:
  build-verify:

    strategy:
      matrix:
        os: ${{ github.event.inputs.single_platform == 'ubuntu-latest' && fromJSON('["ubuntu-latest"]') || github.event.inputs.single_platform == 'windows-latest' && fromJSON('["windows-latest"]') || fromJSON('["ubuntu-latest", "windows-latest"]') }}

    runs-on: ${{ matrix.os }}

    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4
        with:
          show-progress: true

      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ env.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: false
          enable-debug: true

      - name: Debug Environment (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          echo "=== Windows Debug Information ==="
          echo "OS: $RUNNER_OS"
          echo "Operating System: $(uname -a 2>/dev/null || echo 'N/A')"
          echo "PowerShell version:"
          pwsh --version 2>/dev/null || echo "PowerShell not available"
          echo "Git version:"
          git --version 2>/dev/null || echo "Git not available"
          echo "Java version:"
          java -version 2>&1 || echo "Java not available"
          echo "Current working directory: $(pwd)"
          echo "Directory contents:"
          ls -la . || dir
          echo "Environment variables:"
          env | grep -E '^(GRADLE|JAVA|PATH|GH_|GITHUB_)' | sort
          echo "=== End Debug Information ==="

      - name: Dump environment info
        shell: bash
        run: |
          echo "*** Branch (github.ref)    : ${{ github.ref }}"
          echo "*** Commit (github.sha)    : ${{ github.sha }}"
          echo "*** Runner OS              : ${{ runner.os }}"
          echo "*** Workflow dispatch inputs:"
          echo "    always_publish_snapshot: '${{ github.event.inputs.always_publish_snapshot }}'"
          echo "    always_build_docker_image: '${{ github.event.inputs.always_build_docker_image }}'"
          echo "    run_manual_tests: '${{ github.event.inputs.run_manual_tests }}'"
          echo "    run_manual_tests_parallel: '${{ github.event.inputs.run_manual_tests_parallel }}'"
          echo "    extra_gradle_options: '${{ github.event.inputs.extra_gradle_options }}'"
          echo "*** Environment variables:"
          echo "    always_publish_snapshot: '${{ env.always_publish_snapshot }}'"
          echo "    run_manual_tests: '${{ env.run_manual_tests }}'"
          echo "    run_manual_tests_parallel: '${{ env.run_manual_tests_parallel }}'"
          echo "*** Java system properties :" 
          java -XshowSettings:properties --version

      - name: Build the XDK and create a distribution layout
        shell: bash
        # No JAVA_OPTS needed for general builds
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          cwd_path=$(pwd)
          echo "Executing Gradle 'installDist' task from path: '$cwd_path'"
          echo "Skipping 'gradle clean' - fresh runner + cache integrity guaranteed"
          ls -la build/ 2>/dev/null && echo "WARNING: build/ directory exists on fresh runner!" || echo "‚úÖ Confirmed: No previous build outputs"
          
          echo "üîß JVM Configuration:"
          echo "  No special JAVA_OPTS for general builds"
          
          # Print JVM flags for debugging  
          echo "üîç JVM Flag Information:"
          java -XX:+PrintFlagsFinal -version 2>&1 || echo "  Flag printing failed (non-fatal)"
          
          inspect_gradle_cache "before installDist"
          ./gradlew ${{ env.gradle_options }} installDist xdk:distZip 

      - name: Build a machine specific XDK installation with native launchers, test run launchers on native platform
        shell: bash
        # No JAVA_OPTS needed for general builds
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before native launcher build"
          ./gradlew ${{ env.gradle_options }} xdk:installWithLaunchersDist
          xcc_path=$(find xdk/build/install/ -name xcc)
          xec_path=$(find xdk/build/install/ -name xec)
          echo "Location of native launcher (xcc): $xcc_path"
          echo "Location of native launcher (xec): $xec_path"
          echo "*** Testing native launchers, verifying their binary format and that they run on this platform..."
          xcc_file=$(file $xcc_path)
          xec_file=$(file $xec_path)
          xcc_version=$($xcc_path --version)
          xec_version=$($xec_path --version)
          echo "    xcc:"
          echo "        file   : $xcc_file"
          echo "        version: $xcc_version"
          echo "    xec:"
          echo "        file   : $xec_file"
          echo "        version: $xec_version"
          echo "*** Native launchers work."

      - name: Manual tests
        if: ${{ env.run_manual_tests == 'true' }}
        timeout-minutes: 10
        shell: bash
        # No JAVA_OPTS needed for general builds
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before manual tests"
          
          # Always run basic manual tests
          ./gradlew ${{ env.gradle_options }} manualTests:runXtc
          ./gradlew ${{ env.gradle_options }} manualTests:runOne -PtestName=TestMisc
          ./gradlew ${{ env.gradle_options }} manualTests:runTwoTestsInSequence
          
          # Run parallel or sequential tests based on setting
          MANUAL_TASK=$( [ "${{ env.run_manual_tests_parallel }}" = "true" ] && echo "runParallel" || echo "runSequential" )
          ./gradlew ${{ env.gradle_options }} manualTests:$MANUAL_TASK

      - name: Upload XDK distribution ZIP for Docker builds
        if: ${{ success() && matrix.os == 'ubuntu-latest' }}
        uses: actions/upload-artifact@v4
        with:
          name: xdk-distribution
          path: xdk/build/distributions/xdk-*.zip
          retention-days: 1

  publish-snapshot:
    name: Publish to GitHub packages iff snapshot + non-redundant build platform + branch is master
    # Only run if ALL build-verify matrix jobs succeed (both ubuntu-latest and windows-latest)
    needs: build-verify
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_publish_snapshot == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      # Check out current repository
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ env.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: true  # Read-only since build-verify already populated cache
          enable-debug: false

      - name: Debug publish conditions and verify all tests passed
        run: |
          echo "üêõ Debug publish job conditions:"
          echo "  always_publish_snapshot input: '${{ github.event.inputs.always_publish_snapshot }}'"
          echo "  github.ref: '${{ github.ref }}'"
          echo "  Condition should be: always_publish_snapshot == 'true' OR github.ref == 'refs/heads/master'"
          echo "  This job should NOT run on non-master branch without explicit flag!"
          echo ""
          echo "‚úÖ All build-verify matrix jobs (Ubuntu + Windows) completed successfully"
          echo "‚úÖ All tests passed - proceeding with publication"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: xdk-distribution
          path: .

      - name: Dump environment info
        shell: bash
        run: |
          echo "*** Branch (github.ref)    : ${{ github.ref }}"
          echo "*** Commit (github.sha)    : ${{ github.sha }}"
          echo "*** Runner OS              : ${{ runner.os }}"
          echo "*** Workflow inputs:"
          echo "    always_publish_snapshot (raw): '${{ github.event.inputs.always_publish_snapshot }}'"
          echo "    always_publish_snapshot (env): '${{ env.always_publish_snapshot }}'"
          echo "*** Java system properties :" 
          java -XshowSettings:properties --version

      - name: Create or Update Snapshot (if pushed to 'master', or env.always_publish_snapshot is true)
        if: ${{ (github.event.inputs.always_publish_snapshot == 'true') || (github.ref == 'refs/heads/master') }}
        shell: bash
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before publishing (reused from build-verify)"
          
          echo "Reusing build cache from build-verify job..."
          ./gradlew ${{ env.gradle_options }} xdk:ensureTags -PsnapshotOnly=true
          ./gradlew ${{ env.gradle_options }} publishRemote -PsnapshotOnly=true

  compute-docker-tags:
    name: Compute Docker tags and metadata
    needs: build-verify
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.ref == 'refs/heads/master')) }}
    outputs:
      version: ${{ steps.compute.outputs.version }}
      branch-tag: ${{ steps.compute.outputs.branch-tag }}
      tags-json: ${{ steps.compute.outputs.tags-json }}
      is-master: ${{ steps.compute.outputs.is-master }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Compute tags and metadata
        id: compute
        shell: bash
        run: |
          set -euo pipefail
          
          # Read version from properties file
          VERSION=$(grep "^xdk.version=" version.properties | cut -d'=' -f2 | tr -d '\n\r ')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Sanitize branch name for Docker tags
          BRANCH_TAG=$(echo "${{ env.GH_BRANCH }}" | sed 's|.*/||' | sed 's/[^a-zA-Z0-9._-]/_/g')
          echo "branch-tag=$BRANCH_TAG" >> $GITHUB_OUTPUT
          
          # Determine if master branch
          IS_MASTER=${{ github.ref == 'refs/heads/master' }}
          echo "is-master=$IS_MASTER" >> $GITHUB_OUTPUT
          
          # Generate base tags
          if [ "$IS_MASTER" = "true" ]; then
            BASE_TAGS='["latest", "'$VERSION'", "'${{ env.GH_COMMIT }}'"]'
          else
            BASE_TAGS='["'$BRANCH_TAG'", "'${{ env.GH_COMMIT }}'"]'
          fi
          
          echo "tags-json=$BASE_TAGS" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Computed Docker metadata:"
          echo "  Version: $VERSION"
          echo "  Branch tag: $BRANCH_TAG"
          echo "  Is master: $IS_MASTER"
          echo "  Base tags: $BASE_TAGS"

  docker-build:
    name: Build and push Docker images
    needs: compute-docker-tags
    runs-on: ${{ matrix.runner }}
    if: ${{ success() }}
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            arch: amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            arch: arm64
            runner: ubuntu-24.04-arm
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      # Set up Java and Gradle to warm cache for Docker build
      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ env.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: true  # Read-only since build-verify already populated cache
          enable-debug: false

      # Note: Dockerfile is self-contained and downloads source itself
      # But now Docker build can benefit from Gradle cache via GitHub Actions cache

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifacts from build-verify
        uses: actions/download-artifact@v4
        with:
          name: xdk-distribution
          path: .

      - name: Build and push Docker image with pre-built artifacts (${{ matrix.arch }})
        id: build
        shell: bash
        working-directory: docker
        run: |
          set -euo pipefail
          
          echo "Building and pushing ${{ matrix.arch }} Docker image with pre-built artifacts..."
          
          # Use computed metadata from previous job (single source of truth)
          VERSION="${{ needs.compute-docker-tags.outputs.version }}"
          BRANCH_TAG="${{ needs.compute-docker-tags.outputs.branch-tag }}"
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          # Generate architecture-specific tags
          TAGS=$(echo "$BASE_TAGS" | jq -r --arg base "${{ env.DOCKER_BASE_IMAGE }}" --arg arch "${{ matrix.arch }}" '.[] | $base + ":" + . + "-" + $arch')
          TAG_ARGS=""
          for tag in $TAGS; do
            TAG_ARGS="$TAG_ARGS --tag $tag"
          done
          
          echo "üè∑Ô∏è Architecture-specific tags for ${{ matrix.arch }}:"
          echo "$TAGS" | while read tag; do echo "  $tag"; done
          
          # Validate downloaded artifacts exist and show structure
          echo "üìã Pre-built artifacts validation:"
          echo "  Downloaded files in parent directory:"
          ls -la ../ | grep -E '(xdk|zip)' || echo "No XDK files found"
          
          # Platform safety check
          echo "üîç Platform safety validation:"
          echo "  Target platform: ${{ matrix.platform }}"
          echo "  Target arch: ${{ matrix.arch }}"
          echo "  Runner arch: $(uname -m)"
          
          # Build with pre-built artifacts (fast path - no Gradle execution in container)
          # Find platform-agnostic distribution ZIP
          DIST_ZIP_FILE=$(find ../ -name "xdk-*.zip" | head -1)
          if [ -z "$DIST_ZIP_FILE" ]; then
            echo "‚ùå No XDK distribution ZIP found in artifacts"
            echo "Available files in parent directory:"
            ls -la ../ || echo "No files"
            exit 1
          fi
          
          # Copy ZIP to Docker build context with standard name
          cp "$DIST_ZIP_FILE" ci-dist.zip
          echo "üì¶ Copied distribution to Docker context: $DIST_ZIP_FILE ‚Üí ci-dist.zip"
          
          docker buildx build \
            --platform ${{ matrix.platform }} \
            --progress=plain \
            $TAG_ARGS \
            --build-arg DIST_ZIP_URL="ci-dist.zip" \
            --build-arg GH_BRANCH=${{ env.GH_BRANCH }} \
            --build-arg GH_COMMIT=${{ env.GH_COMMIT }} \
            --label org.opencontainers.image.created=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --label org.opencontainers.image.revision=${{ env.GH_COMMIT }} \
            --label org.opencontainers.image.version="$VERSION" \
            --label org.opencontainers.image.source=https://github.com/xtclang/xvm/tree/${{ env.GH_BRANCH }} \
            --cache-from type=gha,scope=${{ matrix.arch }} \
            --cache-to type=gha,mode=max,scope=${{ matrix.arch }} \
            --provenance=false \
            --output type=registry \
            .

      - name: Verify images pushed to registry
        shell: bash
        run: |
          set -euo pipefail
          
          # Use computed metadata from previous job
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          # Generate architecture-specific tags
          TAGS=$(echo "$BASE_TAGS" | jq -r --arg base "${{ env.DOCKER_BASE_IMAGE }}" --arg arch "${{ matrix.arch }}" '.[] | $base + ":" + . + "-" + $arch')
          
          echo "Verifying ${{ matrix.arch }} images exist in registry..."
          echo "$TAGS" | while read tag; do
            echo "Checking: $tag"
            if ! docker manifest inspect "$tag" > /dev/null 2>&1; then
              echo "‚ùå ERROR: Image $tag not found in registry!"
              echo "‚ùå Push failed for ${{ matrix.arch }} architecture!"
              exit 1
            fi
            echo "‚úÖ Confirmed: $tag"
          done

  docker-manifest:
    name: Create multi-platform manifest
    needs: [compute-docker-tags, docker-build]
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify all architecture images exist
        shell: bash  
        run: |
          set -euo pipefail
          
          # Use computed metadata from compute-docker-tags job
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          echo "Verifying all architecture-specific images exist before creating manifests..."
          echo "$BASE_TAGS" | jq -r '.[]' | while read base_tag; do
            for arch in amd64 arm64; do
              arch_tag="${{ env.DOCKER_BASE_IMAGE }}:$base_tag-$arch"
              echo "Checking: $arch_tag"
              if ! docker manifest inspect "$arch_tag" > /dev/null 2>&1; then
                echo "‚ùå ERROR: Image $arch_tag not found in registry!"
                echo "‚ùå Cannot create multi-platform manifest without all architectures!"
                exit 1
              fi
              echo "‚úÖ Confirmed: $arch_tag"
            done
          done

      - name: Create and push multi-platform manifests
        shell: bash
        run: |
          set -euo pipefail
          
          echo "Creating multi-platform manifests from pre-built images..."
          
          # Use computed metadata from compute-docker-tags job
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          # Create and push manifest for each tag
          echo "$BASE_TAGS" | jq -r '.[]' | while read base_tag; do
            manifest_tag="${{ env.DOCKER_BASE_IMAGE }}:$base_tag"
            echo "Creating manifest for: $manifest_tag"
            
            # Create manifest from architecture-specific images
            docker manifest create $manifest_tag \
              $manifest_tag-amd64 \
              $manifest_tag-arm64
            
            # Push the manifest
            docker manifest push $manifest_tag
            
            echo "‚úÖ Created and pushed manifest: $manifest_tag"
          done
          
          echo "üéâ All multi-platform manifests created successfully!"

  docker-test:
    name: Test Docker image functionality
    needs: [compute-docker-tags, docker-manifest]
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Test Docker image functionality with compilation and execution
        shell: bash
        run: |
          # Use the appropriate image tag based on branch
          if [ "${{ needs.compute-docker-tags.outputs.is-master }}" = "true" ]; then
            IMAGE="${{ env.DOCKER_BASE_IMAGE }}:latest"
          else
            IMAGE="${{ env.DOCKER_BASE_IMAGE }}:${{ needs.compute-docker-tags.outputs.branch-tag }}"
          fi
          
          echo "üß™ Testing Docker image: $IMAGE"
          echo "This tests compilation and execution of XTC programs with different parameters"
          
          # Test launcher versions
          echo "üîß Testing launchers..."
          docker run --rm ${IMAGE} xec --version
          docker run --rm ${IMAGE} xcc --version
          
          # Test compilation and execution with different argument patterns (like original EchoTest)
          echo "üß™ Testing XTC program compilation and execution..."
          
          echo "üìã Testing with no arguments..."
          output_0=$(docker run --rm ${IMAGE} xec /opt/xdk/test/DockerTest.x 2>&1)
          echo "$output_0"
          if ! echo "$output_0" | grep -q "DockerTest invoked with 0 arguments\."; then
            echo "‚ùå No arguments test failed"
            exit 1
          fi
          echo "‚úÖ No arguments test passed"
          
          echo "üìã Testing with single argument..."
          output_1=$(docker run --rm ${IMAGE} xec /opt/xdk/test/DockerTest.x "hello" 2>&1)
          echo "$output_1"
          if ! echo "$output_1" | grep -q "DockerTest invoked with 1 arguments:" || ! echo "$output_1" | grep -q '\[1\]="hello"'; then
            echo "‚ùå Single argument test failed"
            exit 1
          fi
          echo "‚úÖ Single argument test passed"
          
          echo "üìã Testing with multiple arguments..."
          output_3=$(docker run --rm ${IMAGE} xec /opt/xdk/test/DockerTest.x "arg1" "arg with spaces" "arg3" 2>&1)
          echo "$output_3"
          if ! echo "$output_3" | grep -q "DockerTest invoked with 3 arguments:" || \
             ! echo "$output_3" | grep -q '\[1\]="arg1"' || \
             ! echo "$output_3" | grep -q '\[2\]="arg with spaces"' || \
             ! echo "$output_3" | grep -q '\[3\]="arg3"'; then
            echo "‚ùå Multiple arguments test failed"
            exit 1
          fi
          echo "‚úÖ Multiple arguments test passed"
          
          echo "üéâ All Docker image functionality tests passed!"
          echo "‚úÖ Native launcher functionality validated"
          echo "‚úÖ XTC program compilation validated" 
          echo "‚úÖ Program execution with 0, 1, and multiple arguments validated"

  docker-cleanup:
    name: Clean up old Docker package versions
    needs: docker-test
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.always_clean_docker == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build

      - name: Clean up Docker package versions with master protection
        run: |
          echo "üßπ Running Docker package cleanup with master image protection..."
          echo "This uses our custom Gradle task with enhanced safety features:"
          echo "  ‚Ä¢ Always protects at least one master image"
          echo "  ‚Ä¢ Keeps 10 most recent versions overall (configurable)"
          echo "  ‚Ä¢ Verifies deletions actually worked"
          echo "  ‚Ä¢ Running without daemon for cleaner process isolation"
          echo ""
          
          # Run cleanup in force mode (no interactive prompts in CI)
          # Use --no-daemon for cleaner process isolation and network handling
          ./gradlew docker:cleanImages -Pforce=true --no-daemon
        env:
          # Use organization-level PAT with delete:packages scope if available, fallback to default token
          GITHUB_TOKEN: ${{ secrets.PACKAGE_DELETE_TOKEN || secrets.GITHUB_TOKEN }}
