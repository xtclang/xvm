#
# GitHub runner workflow for building, verifying and testing the XVM repo.
#
# IMPORTANT: If you manually enable 'always_publish_maven_artifact_snapshot', you MUST also enable 
# 'always_update_homebrew_tap' to keep the Homebrew formula synchronized with the 
# snapshot release. Failing to do so will result in inconsistent package versions.
#
name: XVM Verification and Package Updates

# Grant additional permissions needed for Docker package management  
permissions:
  contents: write
  packages: write
  actions: read
  # Note: GitHub Actions doesn't support packages: delete in permissions
  # Docker cleanup uses PACKAGE_DELETE_TOKEN (org PAT) if available, otherwise shows warnings

on:
  push:
  workflow_dispatch:
    inputs:
      always_publish_maven_artifact_snapshot:
        description: 'Always publish Maven artifact snapshot regardless of branch'
        type: boolean
        required: false
        default: false
      always_build_docker_image:
        description: 'Always build Docker images regardless of branch'
        type: boolean
        required: false
        default: false
      always_clean_docker:
        description: 'Always run Docker cleanup regardless of branch'
        type: boolean
        required: false
        default: false
      always_update_homebrew_tap:
        description: 'Always update Homebrew tap regardless of branch'
        type: boolean
        required: false
        default: false
      as_master:
        description: 'Run branch as if it were master (enables all publish/build/update flags)'
        type: boolean
        required: false
        default: false
      single_platform:
        description: 'Run only single platform (ubuntu-latest, windows-latest, or full matrix)'
        type: choice
        required: false
        default: 'full'
        options:
          - 'full'
          - 'ubuntu-latest'
          - 'windows-latest'
      extra_gradle_options:
        description: 'Extra Gradle options to pass to the build'
        required: false
      run_manual_tests:
        description: 'Run manual tests'
        type: boolean
        required: false
        default: true
      run_manual_tests_parallel:
        description: 'Run manual tests in parallel mode'
        type: boolean
        required: false
        default: false

env:
  # TODO: Default should be disabled; we only want to be bothered by tagging and publishing for the master branch.
  always_publish_maven_artifact_snapshot: ${{ github.event.inputs.always_publish_maven_artifact_snapshot == 'true' || github.event.inputs.as_master == 'true' }}
  always_update_homebrew_tap: ${{ github.event.inputs.always_update_homebrew_tap == 'true' || github.event.inputs.as_master == 'true' }}

  # Add manual tests as an included build to the composite build configuration, and also build them.
  ORG_GRADLE_PROJECT_includeBuildManualTests: true
  ORG_GRADLE_PROJECT_includeBuildAttachManualTests: true
  ORG_GRADLE_PROJECT_xtcPluginOverrideVerboseLogging: true

  # Secrets (TODO: Verify plugin portal and maven central/sonatype credentials)
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GRADLE_PUBLISH_KEY: ${{ secrets.ORG_XTCLANG_GRADLE_PLUGIN_PORTAL_PUBLISH_KEY }}
  GRADLE_PUBLISH_SECRET: ${{ secrets.ORG_XTCLANG_GRADLE_PLUGIN_PORTAL_PUBLISH_SECRET }}
  GPG_SIGNING_KEY: ${{ secrets.ORG_XTCLANG_GPG_SIGNING_KEY }}
  GPG_SIGNING_PASSWORD: ${{ secrets.ORG_XTCLANG_GPG_SIGNING_PASSWORD }}
  MAVEN_CENTRAL_USERNAME: ${{ secrets.ORG_XTCLANG_MAVEN_CENTRAL_USERNAME }}
  MAVEN_CENTRAL_PASSWORD: ${{ secrets.ORG_XTCLANG_MAVEN_CENTRAL_PASSWORD }}

  gradle_options: "-Dorg.gradle.caching.debug=false -Dorg.gradle.vfs.verbose=false -Dorg.gradle.jvmargs='-Xmx4g -XX:+UseG1GC -XX:ParallelGCThreads=2 -XX:ConcGCThreads=1 -XX:+UseStringDeduplication' --stacktrace --warning-mode=all --console=plain ${{ inputs.extra_gradle_options }}"

  # Optional flags to control manual tests
  run_manual_tests: ${{ github.event.inputs.run_manual_tests != 'false' }}
  run_manual_tests_parallel: ${{ github.event.inputs.run_manual_tests_parallel == 'true' }}

  # java_version will be set dynamically from xdk.properties in each job
  java_distribution: temurin
  gradle_version: 8.14.2

  # Docker build variables - computed once, used everywhere
  GH_COMMIT: ${{ github.sha }}
  GH_BRANCH: ${{ github.ref_name }}
  DOCKER_BASE_IMAGE: ghcr.io/xtclang/xvm

  # Gradle cache inspection function
  GRADLE_CACHE_INSPECT: |
    inspect_gradle_cache() {
      local label="${1:-}"
      local gradle_home="${GRADLE_USER_HOME:-$HOME/.gradle}"
      echo "üîç Gradle Cache Inspection${label:+ ($label)}:"
      echo "  Cache location: $gradle_home"
      if [ -d "$gradle_home" ]; then
        echo "  Cache exists: ‚úÖ"
        local total_size=$(du -sh "$gradle_home" 2>/dev/null | cut -f1 || echo "unknown")
        local total_bytes=$(du -sb "$gradle_home" 2>/dev/null | cut -f1 || echo "unknown")
        echo "  Cache size: $total_size ($total_bytes bytes)"
        for dir in caches wrapper build-cache; do
          if [ -d "$gradle_home/$dir" ]; then
            local dir_size=$(du -sh "$gradle_home/$dir" 2>/dev/null | cut -f1 || echo "unknown")
            echo "    $dir: $dir_size"
          fi
        done
      else
        echo "  Cache exists: ‚ùå"
      fi
    }

  # Build environment and build workflow debug flags.
  # ACTIONS_RUNNER_DEBUG: true
  # ACTIONS_STEP_DEBUG: true
  GRADLE_BUILD_ACTION_CACHE_DEBUG_ENABLED: false

# Concurrency settings: group by workflow and ref, cancel intermediate builds, but only if it's a pull request build.
concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: ${{ github.ref != 'refs/heads/master' }}

jobs:
  build-verify:

    strategy:
      matrix:
        os: ${{ github.event.inputs.single_platform == 'ubuntu-latest' && fromJSON('["ubuntu-latest"]') || github.event.inputs.single_platform == 'windows-latest' && fromJSON('["windows-latest"]') || fromJSON('["ubuntu-latest", "windows-latest"]') }}

    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4
        with:
          show-progress: true

      - name: Get Java version from XDK properties
        id: java_version
        uses: ./.github/actions/get-java-version

      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ steps.java_version.outputs.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: false
          enable-debug: true

      - name: Debug Environment (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          echo "=== Windows Debug Information ==="
          echo "OS: $RUNNER_OS"
          echo "Operating System: $(uname -a 2>/dev/null || echo 'N/A')"
          echo "PowerShell version:"
          pwsh --version 2>/dev/null || echo "PowerShell not available"
          echo "Git version:"
          git --version 2>/dev/null || echo "Git not available"
          echo "Java version:"
          java -version 2>&1 || echo "Java not available"
          echo "Current working directory: $(pwd)"
          echo "Directory contents:"
          ls -la . || dir
          echo "Environment variables:"
          env | grep -E '^(GRADLE|JAVA|PATH|GH_|GITHUB_)' | sort
          echo "=== End Debug Information ==="

      - name: Dump environment info
        shell: bash
        run: |
          echo "*** Branch (github.ref)    : ${{ github.ref }}"
          echo "*** Commit (github.sha)    : ${{ github.sha }}"
          echo "*** Runner OS              : ${{ runner.os }}"
          echo "*** Workflow dispatch inputs:"
          echo "    always_publish_maven_artifact_snapshot: '${{ github.event.inputs.always_publish_maven_artifact_snapshot }}'"
          echo "    always_build_docker_image: '${{ github.event.inputs.always_build_docker_image }}'"
          echo "    always_clean_docker: '${{ github.event.inputs.always_clean_docker }}'"
          echo "    always_update_homebrew_tap: '${{ github.event.inputs.always_update_homebrew_tap }}'"
          echo "    as_master: '${{ github.event.inputs.as_master }}'"
          echo "    single_platform: '${{ github.event.inputs.single_platform }}'"
          echo "    run_manual_tests: '${{ github.event.inputs.run_manual_tests }}'"
          echo "    run_manual_tests_parallel: '${{ github.event.inputs.run_manual_tests_parallel }}'"
          echo "    extra_gradle_options: '${{ github.event.inputs.extra_gradle_options }}'"
          echo "*** Environment variables:"
          echo "    always_publish_maven_artifact_snapshot: '${{ env.always_publish_maven_artifact_snapshot }}'"
          echo "    run_manual_tests: '${{ env.run_manual_tests }}'"
          echo "    run_manual_tests_parallel: '${{ env.run_manual_tests_parallel }}'"
          echo "*** Java system properties :" 
          java -XshowSettings:properties --version

      - name: Build the XDK and create a distribution layout
        shell: bash
        # No JAVA_OPTS needed for general builds
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          cwd_path=$(pwd)
          echo "Executing Gradle 'clean' and 'installDist' tasks from path: '$cwd_path'"
          echo "Running clean to validate dependency graph integrity and catch missing dependencies"
          ls -la build/ 2>/dev/null && echo "Build directory exists - will be cleaned" || echo "‚úÖ Confirmed: No previous build outputs"
          
          echo "üîß JVM Configuration:"
          echo "  No special JAVA_OPTS for general builds"
          
          # Print JVM flags for debugging  
          echo "üîç JVM Flag Information:"
          java -XX:+PrintFlagsFinal -version 2>&1 || echo "  Flag printing failed (non-fatal)"
          
          inspect_gradle_cache "before clean and distZip"
          ./gradlew ${{ env.gradle_options }} clean
          ./gradlew ${{ env.gradle_options }} :xdk:distZip
          
          # Run manual tests inline if enabled (avoids cache rebuild)
          if [ "${{ env.run_manual_tests }}" = "true" ]; then
            echo "üß™ Running manual tests inline (cache still hot)..."
            inspect_gradle_cache "before manual tests (inline)"
            
            # Always run basic manual tests
            ./gradlew ${{ env.gradle_options }} manualTests:runXtc
            ./gradlew ${{ env.gradle_options }} manualTests:runOne -PtestName=TestMisc
            ./gradlew ${{ env.gradle_options }} manualTests:runTwoTestsInSequence
            
            # Run parallel or sequential tests based on setting
            MANUAL_TASK=$( [ "${{ env.run_manual_tests_parallel }}" = "true" ] && echo "runParallel" || echo "runAllTestTasks" )
            echo "Running manual tests with given configuration: $MANUAL_TASK"
            ./gradlew ${{ env.gradle_options }} manualTests:$MANUAL_TASK
            
            inspect_gradle_cache "after manual tests (inline)"
            echo "‚úÖ Manual tests completed inline"
          else
            echo "‚è≠Ô∏è Manual tests skipped (disabled)"
          fi

      - name: Prepare Snapshot Release
        if: ${{ success() && matrix.os == 'ubuntu-latest' && ((github.event.inputs.always_update_homebrew_tap == 'true') || (github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
        id: get_version
        uses: ./.github/actions/get-xdk-version

      - name: Create Snapshot Release (directly from build)
        if: ${{ success() && matrix.os == 'ubuntu-latest' && ((github.event.inputs.always_update_homebrew_tap == 'true') || (github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
        shell: bash
        run: |
          # Copy the built zip to current directory for the action to find
          cp xdk/build/distributions/xdk-*.zip ./          
          XDK_ZIP=$(find . -name "xdk-*.zip" | head -1)
          XDK_ZIP=$(basename "$XDK_ZIP")          
          echo "Found XDK zip: $XDK_ZIP"
          
        # Now call the create-snapshot-release action
      - name: Upload Snapshot Release to GitHub
        if: ${{ success() && matrix.os == 'ubuntu-latest' && ((github.event.inputs.always_update_homebrew_tap == 'true') || (github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
        uses: ./.github/actions/create-snapshot-release
        with:
          xdk_version: ${{ steps.get_version.outputs.version }}
          commit_sha: ${{ github.sha }}
          xdk_zip_name: "xdk-${{ steps.get_version.outputs.version }}.zip"
          github_token: ${{ secrets.GITHUB_TOKEN }}


  publish-maven-artifact-snapshot:
    name: Publish Maven artifacts to GitHub packages iff snapshot + non-redundant build platform + branch is master
    # Only run if ALL build-verify matrix jobs succeed (both ubuntu-latest and windows-latest)
    needs: build-verify
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_publish_maven_artifact_snapshot == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      # Check out current repository
      - name: Fetch SourcesAdd
        uses: actions/checkout@v4

      - name: Get Java version from XDK properties
        id: java_version
        uses: ./.github/actions/get-java-version

      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ steps.java_version.outputs.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: true  # Read-only since build-verify already populated cache
          enable-debug: false

      - name: Debug publish conditions and verify all tests passed
        run: |
          echo "üêõ Debug publish job conditions:"
          echo "  always_publish_maven_artifact_snapshot input: '${{ github.event.inputs.always_publish_maven_artifact_snapshot }}'"
          echo "  github.ref: '${{ github.ref }}'"
          echo "  Condition should be: always_publish_maven_artifact_snapshot == 'true' OR github.ref == 'refs/heads/master'"
          echo "  This job should NOT run on non-master branch without explicit flag!"
          echo ""
          echo "‚úÖ All build-verify matrix jobs (Ubuntu + Windows) completed successfully"
          echo "‚úÖ All tests passed - proceeding with publication"

      - name: Dump environment info
        shell: bash
        run: |
          echo "*** Branch (github.ref)    : ${{ github.ref }}"
          echo "*** Commit (github.sha)    : ${{ github.sha }}"
          echo "*** Runner OS              : ${{ runner.os }}"
          echo "*** Workflow inputs:"
          echo "    always_publish_maven_artifact_snapshot (raw): '${{ github.event.inputs.always_publish_maven_artifact_snapshot }}'"
          echo "    always_publish_maven_artifact_snapshot (env): '${{ env.always_publish_maven_artifact_snapshot }}'"
          echo "*** Java system properties :" 
          java -XshowSettings:properties --version

      - name: Create or Update Maven Artifact Snapshot (if pushed to 'master', or env.always_publish_maven_artifact_snapshot is true)
        if: ${{ (github.event.inputs.always_publish_maven_artifact_snapshot == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master') }}
        shell: bash
        run: |
          ${{ env.GRADLE_CACHE_INSPECT }}
          
          inspect_gradle_cache "before publishing (reused from build-verify)"
          
          echo "Reusing build cache from build-verify job..."
          ./gradlew ${{ env.gradle_options }} xdk:ensureTags -PsnapshotOnly=true
          ./gradlew ${{ env.gradle_options }} publishRemote -PsnapshotOnly=true

  compute-docker-tags:
    name: Compute Docker tags and metadata
    needs: build-verify
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    outputs:
      version: ${{ steps.compute.outputs.version }}
      branch-tag: ${{ steps.compute.outputs.branch-tag }}
      tags-json: ${{ steps.generate.outputs.tags-json }}
      is-master: ${{ steps.generate.outputs.is-master }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Compute tags and metadata
        id: compute
        uses: ./.github/actions/compute-docker-tags
        with:
          base-image: ${{ env.DOCKER_BASE_IMAGE }}
          branch: ${{ env.GH_BRANCH }}
          commit: ${{ github.sha }}
      
      - name: Generate Docker tags and metadata
        id: generate
        shell: bash
        run: |
          # Determine if master branch
          IS_MASTER=${{ github.ref == 'refs/heads/master' }}
          echo "is-master=$IS_MASTER" >> $GITHUB_OUTPUT
          
          # Get version and branch tag from compute action
          VERSION="${{ steps.compute.outputs.version }}"
          BRANCH_TAG="${{ steps.compute.outputs.branch-tag }}"
          
          # Generate base tags
          if [ "$IS_MASTER" = "true" ]; then
            BASE_TAGS='["latest","'$VERSION'","'${{ env.GH_COMMIT }}'"]'
          else
            BASE_TAGS='["'$BRANCH_TAG'","'${{ env.GH_COMMIT }}'"]'
          fi
          
          echo "tags-json=$BASE_TAGS" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Computed Docker metadata:"
          echo "  Version: $VERSION"
          echo "  Branch tag: $BRANCH_TAG"
          echo "  Is master: $IS_MASTER"
          echo "  Base tags: $BASE_TAGS"

  docker-build:
    name: Build and push Docker images
    needs: [compute-docker-tags, build-verify]  # Depends on build-verify creating snapshot release
    runs-on: ${{ matrix.runner }}
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            arch: amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            arch: arm64
            runner: ubuntu-24.04-arm
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Get Java version from XDK properties
        id: java_version
        uses: ./.github/actions/get-java-version

      # Set up Java and Gradle to warm cache for Docker build
      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ steps.java_version.outputs.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: true  # Read-only since build-verify already populated cache
          enable-debug: false

      # Note: Dockerfile is self-contained and downloads source itself
      # But now Docker build can benefit from Gradle cache via GitHub Actions cache

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download XDK from Snapshot Release
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì• Downloading XDK from snapshot release created by build-verify..."
          gh release download xdk-latest-snapshot --pattern "xdk-*.zip"
          XDK_ZIP=$(find . -name "xdk-*.zip" | head -1)
          if [ -z "$XDK_ZIP" ]; then
            echo "‚ùå Failed to download XDK from snapshot release"
            exit 1
          fi
          echo "‚úÖ Downloaded XDK: $(basename "$XDK_ZIP")"

      - name: Build and push Docker image with pre-built artifacts (${{ matrix.arch }})
        id: build
        shell: bash
        working-directory: docker
        run: |
          set -euo pipefail
          
          echo "Building and pushing ${{ matrix.arch }} Docker image with pre-built artifacts..."
          
          # Use computed metadata from previous job (single source of truth)
          VERSION="${{ needs.compute-docker-tags.outputs.version }}"
          BRANCH_TAG="${{ needs.compute-docker-tags.outputs.branch-tag }}"
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          # Generate architecture-specific tags
          TAGS=$(echo "$BASE_TAGS" | jq -r --arg base "${{ env.DOCKER_BASE_IMAGE }}" --arg arch "${{ matrix.arch }}" '.[] | $base + ":" + . + "-" + $arch')
          TAG_ARGS=""
          for tag in $TAGS; do
            TAG_ARGS="$TAG_ARGS --tag $tag"
          done
          
          echo "üè∑Ô∏è Architecture-specific tags for ${{ matrix.arch }}:"
          echo "$TAGS" | while read tag; do echo "  $tag"; done
          
          # Validate downloaded snapshot release exists
          echo "üìã Snapshot release validation:"
          echo "  Downloaded files in parent directory:"
          ls -la ../ | grep -E '(xdk|zip)' || echo "No XDK files found"
          
          # Platform safety check
          echo "üîç Platform safety validation:"
          echo "  Target platform: ${{ matrix.platform }}"
          echo "  Target arch: ${{ matrix.arch }}"
          echo "  Runner arch: $(uname -m)"
          
          # Build with snapshot release ZIP (fast path - no Gradle execution in container)
          # Find the XDK distribution ZIP from snapshot release
          DIST_ZIP_FILE=$(find ../ -name "xdk-*.zip" | head -1)
          if [ -z "$DIST_ZIP_FILE" ]; then
            echo "‚ùå No XDK distribution ZIP found in artifacts"
            echo "Available files in parent directory:"
            ls -la ../ || echo "No files"
            exit 1
          fi
          
          # Copy ZIP to Docker build context with standard name
          cp "$DIST_ZIP_FILE" ci-dist.zip
          echo "üì¶ Copied distribution to Docker context: $DIST_ZIP_FILE ‚Üí ci-dist.zip"
          
          docker buildx build \
            --platform ${{ matrix.platform }} \
            --progress=plain \
            $TAG_ARGS \
            --build-arg JAVA_VERSION=${{ steps.java_version.outputs.java_version }} \
            --build-arg DIST_ZIP_URL="ci-dist.zip" \
            --build-arg GH_BRANCH=${{ env.GH_BRANCH }} \
            --build-arg GH_COMMIT=${{ env.GH_COMMIT }} \
            --label org.opencontainers.image.created=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --label org.opencontainers.image.revision=${{ env.GH_COMMIT }} \
            --label org.opencontainers.image.version="$VERSION" \
            --label org.opencontainers.image.source=https://github.com/xtclang/xvm/tree/${{ env.GH_BRANCH }} \
            --cache-from type=gha,scope=${{ matrix.arch }} \
            --cache-to type=gha,mode=max,scope=${{ matrix.arch }} \
            --provenance=false \
            --output type=registry \
            .
          
          echo ""
          echo "üê≥ Docker images built and pushed for ${{ matrix.arch }} architecture!"
          echo ""
          echo "üìã Usage examples:"
          
          # Show primary tag usage (will be available after manifest creation)
          PRIMARY_TAG="${{ needs.compute-docker-tags.outputs.latest-tag }}"
          echo "# Primary tag (multi-platform, available after manifest creation):"
          echo "docker run --rm -v \$(pwd):/workspace ${{ env.DOCKER_BASE_IMAGE }}:$PRIMARY_TAG xcc /workspace/MyModule.x"
          echo "docker run --rm -v \$(pwd):/workspace ${{ env.DOCKER_BASE_IMAGE }}:$PRIMARY_TAG xec /workspace/MyModule"
          echo "docker run -it --rm -v \$(pwd):/workspace ${{ env.DOCKER_BASE_IMAGE }}:$PRIMARY_TAG bash"
          echo ""
          
          # Show architecture-specific tags (available immediately)
          echo "# Architecture-specific tags (available immediately):"
          echo "$TAGS" | while read tag; do
            echo "docker run --rm --platform=${{ matrix.platform }} -v \$(pwd):/workspace $tag xcc /workspace/MyModule.x"
            # TODO: Uncomment this break to limit everything to one example per architecture:
            #break
          done
          echo ""

      - name: Verify images pushed to registry
        shell: bash
        run: |
          set -euo pipefail
          
          # Use computed metadata from previous job
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          # Generate architecture-specific tags
          TAGS=$(echo "$BASE_TAGS" | jq -r --arg base "${{ env.DOCKER_BASE_IMAGE }}" --arg arch "${{ matrix.arch }}" '.[] | $base + ":" + . + "-" + $arch')
          
          echo "Verifying ${{ matrix.arch }} images exist in registry..."
          echo "$TAGS" | while read tag; do
            echo "Checking: $tag"
            if ! docker manifest inspect "$tag" > /dev/null 2>&1; then
              echo "‚ùå ERROR: Image $tag not found in registry!"
              echo "‚ùå Push failed for ${{ matrix.arch }} architecture!"
              exit 1
            fi
            echo "‚úÖ Confirmed: $tag"
          done

  docker-manifest:
    name: Create multi-platform manifest
    needs: [compute-docker-tags, docker-build]
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify all architecture images exist
        shell: bash  
        run: |
          set -euo pipefail
          
          # Use computed metadata from compute-docker-tags job
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          echo "Verifying all architecture-specific images exist before creating manifests..."
          echo "$BASE_TAGS" | jq -r '.[]' | while read base_tag; do
            for arch in amd64 arm64; do
              arch_tag="${{ env.DOCKER_BASE_IMAGE }}:$base_tag-$arch"
              echo "Checking: $arch_tag"
              if ! docker manifest inspect "$arch_tag" > /dev/null 2>&1; then
                echo "‚ùå ERROR: Image $arch_tag not found in registry!"
                echo "‚ùå Cannot create multi-platform manifest without all architectures!"
                exit 1
              fi
              echo "‚úÖ Confirmed: $arch_tag"
            done
          done

      - name: Create and push multi-platform manifests
        shell: bash
        run: |
          set -euo pipefail
          
          echo "Creating multi-platform manifests from pre-built images..."
          
          # Use computed metadata from compute-docker-tags job
          BASE_TAGS='${{ needs.compute-docker-tags.outputs.tags-json }}'
          
          # Create and push manifest for each tag
          echo "$BASE_TAGS" | jq -r '.[]' | while read base_tag; do
            manifest_tag="${{ env.DOCKER_BASE_IMAGE }}:$base_tag"
            echo "Creating manifest for: $manifest_tag"
            
            # Create manifest from architecture-specific images
            docker manifest create $manifest_tag \
              $manifest_tag-amd64 \
              $manifest_tag-arm64
            
            # Push the manifest
            docker manifest push $manifest_tag
            
            echo "‚úÖ Created and pushed manifest: $manifest_tag"
          done
          
          echo "üéâ All multi-platform manifests created successfully!"

  docker-test:
    name: Test Docker image functionality
    needs: [compute-docker-tags, docker-manifest]
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Test Docker image functionality with compilation and execution
        shell: bash
        run: |
          IMAGE="${{ env.DOCKER_BASE_IMAGE }}:${{ github.sha }}"
          BRANCH_IMAGE="${{ env.DOCKER_BASE_IMAGE }}:${{ needs.compute-docker-tags.outputs.is-master == 'true' && 'latest' || needs.compute-docker-tags.outputs.branch-tag }}"
          
          ./.github/scripts/test-docker-image.sh \
            "$IMAGE" \
            "${{ github.sha }}" \
            "${{ github.ref_name }}" \
            "$BRANCH_IMAGE" \
            "${{ needs.compute-docker-tags.outputs.is-master }}"

  docker-cleanup:
    name: Clean up old Docker package versions
    needs: docker-test
    runs-on: ubuntu-latest
    if: ${{ success() && ((github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.always_clean_docker == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Fetch Sources
        uses: actions/checkout@v4

      - name: Get Java version from XDK properties
        id: java_version
        uses: ./.github/actions/get-java-version

      - name: Setup XVM Build Environment
        uses: ./.github/actions/setup-xvm-build
        with:
          java-version: ${{ steps.java_version.outputs.java_version }}
          java-distribution: ${{ env.java_distribution }}
          gradle-version: ${{ env.gradle_version }}
          cache-read-only: true

      - name: Clean up Docker package versions with master protection
        run: |
          echo "üßπ Running Docker package cleanup with master image protection..."
          echo "This uses our custom Gradle task with enhanced safety features:"
          echo "  ‚Ä¢ Always protects at least one master image"
          echo "  ‚Ä¢ Keeps 10 most recent versions overall (configurable)"
          echo "  ‚Ä¢ Verifies deletions actually worked"
          echo "  ‚Ä¢ Running without daemon for cleaner process isolation"
          echo ""
          
          # Run cleanup in force mode (no interactive prompts in CI)
          # Use --no-daemon for cleaner process isolation and network handling
          ./gradlew docker:cleanImages -Pforce=true --no-daemon
        env:
          # Use organization-level PAT with delete:packages scope if available, fallback to default token
          GITHUB_TOKEN: ${{ secrets.PACKAGE_DELETE_TOKEN || secrets.GITHUB_TOKEN }}

  update-homebrew-tap:
    name: Update Homebrew tap with latest XDK
    needs: build-verify
    runs-on: ubuntu-latest
    # IMPORTANT: Always run if snapshot release was created to prevent package skew
    if: ${{ success() && ((github.event.inputs.always_update_homebrew_tap == 'true') || (github.event.inputs.always_build_docker_image == 'true') || (github.event.inputs.as_master == 'true') || (github.ref == 'refs/heads/master')) }}
    steps:
      - name: Checkout XVM repository
        uses: actions/checkout@v4

      - name: Get XDK version
        id: version
        uses: ./.github/actions/get-xdk-version

      - name: Get Java version
        id: java_version
        uses: ./.github/actions/get-java-version

      - name: Update Homebrew Tap
        uses: ./.github/actions/update-homebrew-tap
        with:
          xdk_version: ${{ steps.version.outputs.version }}
          commit_sha: ${{ github.sha }}
          java_version: ${{ steps.java_version.outputs.java_version }}
          xdk_zip_name: "xdk-${{ steps.version.outputs.version }}.zip"
          homebrew_tap_token: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          homebrew_tap_branch: ${{ vars.HOMEBREW_TAP_BRANCH || 'master' }}
