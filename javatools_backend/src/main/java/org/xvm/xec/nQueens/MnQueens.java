// ---------------------------------------------------------------
// ---------------------------------------------------------------
// Auto Generated by XEC from C:\Users\cliffc\Desktop\xvm\doc\examples\nQueens.x

package org.xvm.xec.nQueens;

import org.xvm.xec.*;
import org.xvm.xrun.*;
import static org.xvm.xrun.XRuntime.$t;
import org.xvm.xec.ecstasy.RangeII;
import org.xvm.xec.ecstasy.collections.Aryboolean;
import org.xvm.xec.ecstasy.collections.Tuple1;
import org.xvm.xec.ecstasy.RangeIE;
import org.xvm.xec.ecstasy.Orderable;
import org.xvm.xec.ecstasy.text.StringBuffer;
import org.xvm.xec.ecstasy.collections.AryString;
import org.xvm.xec.ecstasy.io.Console;
import org.xvm.xec.ecstasy.numbers.IntLiteral;
import org.xvm.xec.ecstasy.numbers.Int64;
import org.xvm.xec.ecstasy.collections.Array.Mutability;
import org.xvm.xec.ecstasy.Range;
import org.xvm.xec.ecstasy.Const;
import org.xvm.xec.ecstasy.Ordered;


// XTC module nQueens.x:nQueens as Java class MnQueens
public class MnQueens extends XRunClz {
  static final MnQueens GOLD = new MnQueens((Never)null);
  private MnQueens(Never n){super(n);} // A no-arg-no-work constructor
  public MnQueens( ) { // default XTC empty constructor
    super((Never)null);
  }

  public static void main( String[] args ) {
    GOLD.run(new AryString(1.1,args));
  }
  
  public static MnQueens construct() { return new MnQueens().$construct(); }
  private MnQueens $construct(){ return this; }

  public void run( AryString args ) {
    Console console = org.xvm.XEC.CONTAINER.get().console();
    long extent = 2;
    if(  !args.empty$get()) 
      try {
        extent = IntLiteral.construct(args.at8(0)).toInt();
      }
      catch( Exception $ignore ) {};
    long count = Board.construct(extent).findSolutions(( board) -> {
      console.print(board.appendTo(new StringBuffer()).appendTo("\n").toString(), false);
    });
    console.print(new StringBuffer().appendTo(count).appendTo(" solutions found").toString(), false);
  }

  // XTC class nQueens.x:Board as Java class Board
  public static class Board extends Const {
    static final Board GOLD = new Board((Never)null);
    private Board(Never n){super(n);} // A no-arg-no-work constructor
    public Board( ) { // default XTC empty constructor
      super((Never)null);
    }

    public static Board construct(long extent) { return new Board().$construct(extent); }
    private Board $construct( long extent ) {
      this.extent = extent;
      queens = Aryboolean.construct(extent*extent);
      claimed = Aryboolean.construct(extent*extent);
      return this;
    }

    private static Board construct(long extent, Aryboolean queens, Aryboolean claimed) { return new Board().$construct(extent, queens, claimed); }
    private Board $construct( long extent, Aryboolean queens, Aryboolean claimed ) {
      this.extent = extent;
      this.queens = queens;
      this.claimed = claimed;
      return this;
    }

    // Default equals
    public boolean equals( XTC x0, XTC x1 ) {
      return equals$Board(GOLD,(Board)x0,(Board)x1);
    }
    public static boolean equals$Board( XTC gold, Board x0, Board x1 ) {
      if( x0==x1 ) return true;
      return x0.queens.equals(x1.queens) && x0.claimed.equals(x1.claimed) && x0.extent==x1.extent;
    }

    public boolean safe( long col, long row ) {
      return  !(claimed$get().at8(this.index(col, row)));
    }

    private long index( long col, long row ) {
      return row*extent$get()+col;
    }

    public boolean occupied( long col, long row ) {
      return queens$get().at8(this.index(col, row));
    }
    Aryboolean queens;
    public Aryboolean queens$get() { return queens; }
    public void queens$set( Aryboolean p ) { throw new ReadOnlyException(); }


    public long findSolutions( Fun1Board yield ) {
      return this.findSolutions(yield, 0);
    }

    private long findSolutions( Fun1Board yield, long col ) {
      Range $tmp0;
      if( col==extent$get()) {
        yield.call(this);
        return 1;
      };
      long count = 0;
      $tmp0 = RangeII.construct(extent$get(), 1);
      for( long rank = $tmp0._lo; rank < $tmp0._hi; rank++ ) {
        Board $tmp1;
        long row = extent$get()-rank;
        if( $t($tmp1 = this.placeQueen(col, row)) && XRuntime.GET$COND()) {
          Board afterPlacing = $tmp1;
          count += afterPlacing.findSolutions(yield, col+1);
        };
      };
      return count;
    }

    // Default compare
    public Ordered compare( XTC x0, XTC x1 ) {
      return compare$Board(GOLD,(Board)x0,(Board)x1);
    }
    public static Ordered compare$Board( XTC gold, Board x0,Board x1 ) {
      if( x0==x1 ) return Ordered.Equal;
      Ordered $x;
      if( ($x=Orderable.spaceship( x0.extent,x1.extent)) != Ordered.Equal ) return $x;
      return Ordered.Equal;
    }


    public Board placeQueen( long col, long row ) {
      Range $tmp2;
      long $tmp0, $tmp1;
      XTC.xassert((0 <= ($tmp0=XTC.TRACE(col) ) && $tmp0 < XTC.TRACE(this.extent$get())) && (0 <= ($tmp1=XTC.TRACE(row) ) && $tmp1 < XTC.TRACE(this.extent$get())));
      if(  !this.safe(col, row)) 
        return XRuntime.SET$COND(false,null);
      Aryboolean newQueens = this.queens$get().toArray(Mutability.Fixed, false);
      newQueens.set(this.index(col, row), true);
      Aryboolean newClaimed = this.claimed$get().toArray(Mutability.Fixed, false);
      newClaimed.set(this.index(col, row), true);
      $tmp2 = RangeIE.construct(0, extent$get());
      for( long i = $tmp2._lo; i < $tmp2._hi; i++ ) {
        long $tmp3, $tmp4;
        newClaimed.set(this.index(i, row), true);
        newClaimed.set(this.index(col, i), true);
        long diagDownRow = row+i-col;
        if( 0 <= ($tmp3=diagDownRow ) && $tmp3 < this.extent$get()) 
          newClaimed.set(this.index(i, diagDownRow), true);
        long diagUpRow = row-i+col;
        if( 0 <= ($tmp4=diagUpRow ) && $tmp4 < this.extent$get()) 
          newClaimed.set(this.index(i, diagUpRow), true);
      };
      return XRuntime.SET$COND(true,Board.construct(this.extent$get(), newQueens, newClaimed));
    }
    Aryboolean claimed;
    public Aryboolean claimed$get() { return claimed; }
    public void claimed$set( Aryboolean p ) { throw new ReadOnlyException(); }


    // Default hash
    public long hashCode( XTC x ) { return hashCode$Board(GOLD,(Board)x); }
    public static long hashCode$Board(XTC gold, Board x) {
      return x.queens.hashCode() ^ x.claimed.hashCode() ^ x.extent;
    }

    public String toString(  ) {
      Range $tmp0, $tmp2;
      StringBuffer buf = StringBuffer.construct();
      $tmp0 = RangeII.construct(extent$get(), 1);
      for( long rank = $tmp0._lo; rank < $tmp0._hi; rank++ ) {
        Range $tmp1;
        buf.append(new StringBuffer().appendTo(rank%10).appendTo(" |").toString());
        long row = extent$get()-rank;
        $tmp1 = RangeIE.construct(0, extent$get());
        for( long col = $tmp1._lo; col < $tmp1._hi; col++ ) {
          buf.add(this.occupied(col, row) ? 'q' : '_').add('|');
        };
        buf.add('\n');
      };
      buf.append("  ");
      $tmp2 = RangeIE.construct(0, extent$get());
      for( long col = $tmp2._lo; col < $tmp2._hi; col++ ) {
        buf.add(' ').add('A'+col%26);
      };
      return buf.toString();
    }

    long extent;
    public long extent$get() { return extent; }
    public void extent$set( long p ) { throw new ReadOnlyException(); }

  }
  public void run() { run(new AryString()); }
  public void main( AryString args ) { run( args ); }

  private interface Fun1Board {
    abstract void call( Board x0);
  }

  private class Tuple1$Board extends Tuple1 {
    public Board _f0;
    public Tuple1$Board(Board f0) {
      _f0=f0; 
    }
    public Object f0() { return _f0; }
    public void f0(Object e) { _f0= ((Board)e); }
  }

}
// ---------------------------------------------------------------
