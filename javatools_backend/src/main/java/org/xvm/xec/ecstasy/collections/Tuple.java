package org.xvm.xec.ecstasy.collections;

import org.xvm.XEC;
import org.xvm.util.SB;
import org.xvm.xtc.*;
import org.xvm.xec.XTC;
import org.xvm.xec.ecstasy.AbstractRange;
import org.xvm.xec.ecstasy.Comparable;
import org.xvm.xec.ecstasy.collections.Array.Mutability;

public interface Tuple extends Cloneable {
  // Array-like interface
  abstract public XTC at(long i); // At an index
  abstract public void set(long i, XTC o); // Set an index

  public abstract int size$get();

  // Using slice call instead of array syntax
  default public Tuple slice( AbstractRange r) { return at(r); }

  public abstract Tuple at( AbstractRange r);

  public abstract Mutability mutability$get();

  public abstract Tuple add( XTC x );

  public abstract Tuple addAll( Tuple tup );

  public abstract Tuple ensureMutability(Mutability mut0, boolean inPlace);

  public static boolean equals$Tuple(Tuple0 gold, Tuple0 t0, Tuple0 t1 ) {
    return gold.equals(t0,t1);
  }

  // Return a tuple class for this set of types.  The class is cached, and can
  // be used many times.
  public static XClz make_class( XClz xtt ) {
    // Lookup cached version
    int N = xtt._xts.length;
    if( N==0 ) return xtt; // Tuple0 already exists in the base runtime

    String tclz = xtt.clz(new SB()).toString();
    String pack = (XEC.XCLZ+"."+xtt._pack).intern();
    String qual = (pack+"."+tclz).intern();
    ClzBuilder.add_import(qual);
    if( ClzBldSet.find(qual) ) return xtt;
    /* Gotta build one.  Looks like:
       class Tuple3$long$String$char extends Tuple3 {
         public static Tuple3$long$String$char GOLD = new Tuple3$long$String$char();
         private Tuple3$long$String$char(){}
         public long _f0;
         public String _f1;
         public char _f2;
         Tuple3$long$String$char(long f0, String f1, char f2) {
           _f0=f0; _f1=f1; _f2=f2;
         }
         public Int64  f0() { return Int64.make(_f0); }
         public org.xvm.xec.ecstasy.text.String f1() { return org.xvm.xec.ecstasy.text.String.make(_f1); }
         public Char   f2() { return Char.make(_f2); }
         public void f0(XTC e) { _f0= ((Int64)e)._x; }
         public void f1(XTC e) { _f1= ((org.xvm.xec.ecstasy.text.String)e)._x; }
         public void f2(XTC e) { _f2= ((Char)e)._x; }
         public long   at80() { return _f0; }
         public String at81() { return _f1; }
         public char   at82() { return _f2; }
       }
    */
    // Tuple N class
    SB sb = new SB();
    sb.p("// ---------------------------------------------------------------").nl();
    sb.p("// Auto Generated by Tuple from ").p(tclz).nl().nl();
    sb.fmt("package %0;\n\n",pack);
    sb.fmt("import %0.Tuple%1;\n",pack,N);
    sb.p  ("import org.xvm.xec.XTC;\n");
    xtt.makeImports(sb);

    sb.fmt("public class %0 extends Tuple%1 {\n",tclz,N).ii();
    sb.ifmt("public static %0 GOLD = new %0();",tclz).nl();
    sb.ifmt("private %0(){}",tclz).nl();
    // N field declares
    for( int i=0; i<N; i++ )
      sb.ifmt("public %0 _f%1;\n",xtt._xts[i].clz(),i);

    // Constructor, taking N arguments
    sb.ifmt("public %0(",tclz);
    for( int i=0; i<N; i++ )
      sb.fmt("%0 f%1, ",xtt._xts[i].clz(),i);
    sb.unchar(2).p(") {\n").ii().i();
    // N arg to field assigns
    for( int i=0; i<N; i++ )
      sb.fmt("_f%0=f%0; ",i);
    sb.nl().di().ip("}\n");

    // Factory, taking N arguments and passing them along
    sb.ifmt("public static %0 construct(",tclz);
    for( int i=0; i<N; i++ )
      sb.fmt("%0 f%1, ",xtt._xts[i].clz(),i);
    sb.unchar(2).p(") {\n").ii();
    sb.ifmt("return new %0(",tclz);
    // N arg to field assigns
    for( int i=0; i<N; i++ )
      sb.fmt("f%0, ",i);
    sb.unchar(2).p(" );").nl().di().ip("}\n");

    // Abstract accessors
    for( int i=0; i<N; i++ ) {
      sb.ip("public ");
      XClz clz = xtt._xts[i].box();
      if( clz==null ) xtt._xts[i].clz(sb);
      else clz.clz_bare(sb);
      sb.fmt(" f%0() { return ",i);
      if( clz==xtt._xts[i] || clz==null )  sb.fmt("_f%0",i);   // Bare prims
      else clz.clz_bare(sb).fmt(".make(_f%0)",i); // Box  prims
      sb.p("; }\n");
    }
    // Abstract setters
    for( int i=0; i<N; i++ ) {
      XType xt = xtt._xts[i];
      XType box = xt.box();
      sb.ifmt("public void f%0(XTC e) { _f%0= ((%1)e)%2; }\n",i,box==null ? xt.clz() : box.clz(),xt==box || xt==null?"":"._i");
    }

    // public static boolean equals$Tuple3$...(XTC gold, Tuple0, t0, Tuple0 t1)...
    sb.ifmt("public static boolean equals$%0( XTC gold, %0 x0, %0 x1 ) {\n",tclz).ii();
    sb.ip(  "if( x0==x1 ) return true;\n");
    sb.ip(  "return ");
    for( int i=0; i<N; i++ ) {
      XType xt = xtt._xts[i];
      xt.do_eq(sb.p("x0._f"+i), "x1._f"+i).p(" && ");
    }
    if( N>0 ) sb.unchar(4);
    else sb.p("true");
    sb.p(";\n").di();
    sb.ip("}\n");


    // public boolean equals( Tuple0 t0, Tuple0 t1 ) { ... }
    Comparable.make_equals(tclz,sb);

    // Class end
    sb.di().ip("}\n");
    sb.p("// ---------------------------------------------------------------").nl();
    ClzBldSet.add(qual,sb.toString());

    return xtt;
  }
}
