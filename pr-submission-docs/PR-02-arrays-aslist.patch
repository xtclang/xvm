diff --git a/javatools/src/main/java/org/xvm/asm/ClassStructure.java b/javatools/src/main/java/org/xvm/asm/ClassStructure.java
index 1bc103e5c..ffc4b8b21 100644
@@ -808,7 +804,7 @@ public class ClassStructure
 
         return cActual == cFormal
             ? atypeActual
-            : resolveType(pool, Arrays.asList(atypeActual)).getParamTypesArray();
+            : resolveType(pool, List.of(atypeActual)).getParamTypesArray();
     }
 
     /**
diff --git a/javatools/src/main/java/org/xvm/asm/MethodStructure.java b/javatools/src/main/java/org/xvm/asm/MethodStructure.java
index 64f31eddd..d0bde88be 100644
@@ -238,8 +241,8 @@ public class MethodStructure
      * Replace the annotations with an equivalent re-ordered array.
      */
     public void reorderAnnotations(Annotation[] annotations) {
-        assert new HashSet(Arrays.asList(annotations)).equals(
-               new HashSet(Arrays.asList(m_aAnnotations)));
+        assert new HashSet<>(List.of(annotations)).equals(
+               new HashSet<>(List.of(m_aAnnotations)));
 
         m_aAnnotations = annotations;
     }
@@ -435,7 +435,7 @@ public class MethodStructure
      * @return a list of Parameter structures that represent all return values of the method
      */
     public List<Parameter> getReturns() {
-        return Arrays.asList(m_aReturns);
+        return List.of(m_aReturns);
     }
 
     /**
@@ -528,7 +528,7 @@ public class MethodStructure
      * @return a list of Parameter structures that represent all parameters of the method
      */
     public List<Parameter> getParams() {
-        return Arrays.asList(m_aParams);
+        return List.of(m_aParams);
     }
 
     /**
diff --git a/javatools/src/main/java/org/xvm/asm/constants/ParameterizedTypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/ParameterizedTypeConstant.java
index 0ba085bac..cd4a73944 100644
@@ -156,9 +157,7 @@ public class ParameterizedTypeConstant
 
     @Override
     public List<TypeConstant> getParamTypes() {
-        return m_atypeParams.length == 0
-                ? Collections.emptyList()
-                : Arrays.asList(m_atypeParams);
+        return List.of(m_atypeParams);
     }
 
     @Override
diff --git a/javatools/src/main/java/org/xvm/asm/constants/PropertyInfo.java b/javatools/src/main/java/org/xvm/asm/constants/PropertyInfo.java
index c37076fe4..579564699 100644
@@ -404,8 +401,7 @@ public class PropertyInfo
                     list.add(body);
                 }
             } else if (list == null) {
-                // "Array.asList()" produces an immutable list
-                list = new ArrayList<>(Arrays.asList(aBody).subList(0, i));
+                list = new ArrayList<>(List.of(aBody).subList(0, i));
             }
         }
 
diff --git a/javatools/src/main/java/org/xvm/asm/constants/SignatureConstant.java b/javatools/src/main/java/org/xvm/asm/constants/SignatureConstant.java
index 18d6bd495..7916d799a 100644
@@ -170,7 +171,7 @@ public class SignatureConstant
      * @return the method's parameter types
      */
     public List<TypeConstant> getParams() {
-        return Arrays.asList(m_aconstParams.clone());
+        return List.of(m_aconstParams);
     }
 
     /**
@@ -191,7 +192,7 @@ public class SignatureConstant
      * @return the method's return types
      */
     public List<TypeConstant> getReturns() {
-        return Arrays.asList(m_aconstReturns);
+        return List.of(m_aconstReturns);
     }
 
     /**
diff --git a/javatools/src/main/java/org/xvm/asm/constants/TypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/TypeConstant.java
index 90512a656..9a5fc7389 100644
@@ -2141,16 +2132,13 @@ public abstract class TypeConstant
                 TypeInfo     infoExtend  = contrib.getTypeConstant().ensureTypeInfo();
                 Annotation[] aAnnoExtend = infoExtend.getMixinAnnotations();
                 if (aAnnoExtend.length > 0) {
-                    if (listAnnos == null) {
-                        listAnnos = new ArrayList<>();
-                    }
-                    listAnnos.addAll(Arrays.asList(aAnnoExtend));
+                    Collections.addAll(listAnnos, aAnnoExtend);
                 }
                 break;
             }
             }
         }
-        return listAnnos == null
+        return listAnnos.isEmpty()
                 ? Annotation.NO_ANNOTATIONS
                 : listAnnos.toArray(Annotation.NO_ANNOTATIONS);
     }
diff --git a/javatools/src/main/java/org/xvm/compiler/Parser.java b/javatools/src/main/java/org/xvm/compiler/Parser.java
index 9968dae88..296de7ebb 100644
@@ -1057,7 +1056,7 @@ public class Parser {
             Expression expr = parseExpression();
             Token semi = expect(Id.SEMICOLON);
             ReturnStatement stmt = new ReturnStatement(eq, expr);
-            body = new StatementBlock(Arrays.asList(stmt), stmt.getStartPosition(),
+            body = new StatementBlock(List.of(stmt), stmt.getStartPosition(),
                                                            semi.getEndPosition());
             break;
         default:
@@ -1109,7 +1108,7 @@ public class Parser {
             if (eq != null) {
                 Expression expr = parseExpression();
                 ReturnStatement stmt = new ReturnStatement(eq, expr);
-                block = new StatementBlock(Arrays.asList(stmt), stmt.getStartPosition(),
+                block = new StatementBlock(List.of(stmt), stmt.getStartPosition(),
                                                                 stmt.getEndPosition());
                 fNeedsSemi = true;
             } else {
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/AstNode.java b/javatools/src/main/java/org/xvm/compiler/ast/AstNode.java
index e82fd49d7..bd5dc9515 100644
@@ -1398,7 +1392,7 @@ public abstract class AstNode
             }
         }
 
-        return Arrays.asList(aexpr);
+        return List.of(aexpr);
     }
 
     /**
@@ -1744,11 +1738,11 @@ public abstract class AstNode
             }
             case Object[] kids -> {
                 cKids = kids.length;
-                iterK = Arrays.asList(kids).iterator();
+                iterK = List.of(kids).iterator();
             }
             case null, default -> {
                 cKids = 1;
-                iterK = Collections.singletonList(value).iterator();
+                iterK = List.of(value).iterator();
             }
             }
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/ReturnStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/ReturnStatement.java
index 93f88e704..4974cfbb0 100644
@@ -51,7 +52,7 @@ public class ReturnStatement
     }
 
     public ReturnStatement(Token keyword, Expression expr) {
-        this(keyword, Arrays.asList(expr)); // mutable list
+        this(keyword, List.of(expr));
     }
 
     public ReturnStatement(Token keyword, List<Expression> exprs) {
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/TupleExpression.java b/javatools/src/main/java/org/xvm/compiler/ast/TupleExpression.java
index 9d70e0038..f8084ae64 100644
@@ -58,7 +58,7 @@ public class TupleExpression
         Expression expr0 = aExprs[0];
 
         this.type        = null;
-        this.exprs       = Arrays.asList(aExprs);
+        this.exprs       = List.of(aExprs);
         this.m_lStartPos = expr0.getStartPosition();
         this.m_lEndPos   = aExprs[cExprs-1].getEndPosition();
 
diff --git a/javatools/src/main/java/org/xvm/runtime/template/reflect/xRef.java b/javatools/src/main/java/org/xvm/runtime/template/reflect/xRef.java
index 59da3de34..32142fc37 100644
@@ -220,7 +220,8 @@ public class xRef
                                     typeMask.ensureAccess(Access.PRIVATE),
                                     pool.typeStruct());
         if (typeOrig.isAnnotated()) {
-            List<Annotation> listAnno = Arrays.asList(typeOrig.getAnnotations());
+            // NOTE: This was a bug - Arrays.asList() returns a fixed-size list that doesn't support removeIf()
+            List<Annotation> listAnno = new ArrayList<>(List.of(typeOrig.getAnnotations()));
             listAnno.removeIf(anno -> !anno.getAnnotationType().isShared(pool));
             if (!listAnno.isEmpty()) {
                 typeClz = pool.ensureAnnotatedTypeConstant(typeClz,
diff --git a/javatools/src/main/java/org/xvm/tool/LauncherOptions.java b/javatools/src/main/java/org/xvm/tool/LauncherOptions.java
index c8270f29a..97c6faff9 100644
@@ -546,7 +546,7 @@ public abstract class LauncherOptions {
         }
 
         public T setModulePath(final File... paths) {
-            return setModulePath(Arrays.asList(paths));
+            return setModulePath(List.of(paths));
         }
 
         public T setModulePath(final String... paths) {
@@ -566,7 +566,7 @@ public abstract class LauncherOptions {
         }
 
         public T addModulePath(final File... paths) {
-            return addModulePath(Arrays.asList(paths));
+            return addModulePath(List.of(paths));
         }
 
         public T addModulePath(final String... paths) {
diff --git a/plugin/src/main/java/org/xtclang/plugin/internal/DefaultXtcRuntimeExtension.java b/plugin/src/main/java/org/xtclang/plugin/internal/DefaultXtcRuntimeExtension.java
index 572a6b41f..16414ae57 100644
@@ -53,7 +52,7 @@ public abstract class DefaultXtcRuntimeExtension extends DefaultXtcLauncherTaskE
 
     @Override
     public void moduleNames(final String... names) {
-        Arrays.asList(names).forEach(this::moduleName);
+        List.of(names).forEach(this::moduleName);
     }
 
     @Override
@@ -69,7 +68,7 @@ public abstract class DefaultXtcRuntimeExtension extends DefaultXtcLauncherTaskE
 
     @Override
     public void setModuleNames(final String... moduleNames) {
-        setModuleNames(Arrays.asList(moduleNames));
+        setModuleNames(List.of(moduleNames));
     }
 
     @Override
@@ -80,7 +79,7 @@ public abstract class DefaultXtcRuntimeExtension extends DefaultXtcLauncherTaskE
 
     @Override
     public void setModules(final XtcRunModule... modules) {
-        setModules(Arrays.asList(modules));
+        setModules(List.of(modules));
     }
 
     @Override
diff --git a/plugin/src/main/java/org/xtclang/plugin/launchers/ForkedStrategy.java b/plugin/src/main/java/org/xtclang/plugin/launchers/ForkedStrategy.java
index c1676020b..37bcf220f 100644
@@ -145,7 +144,7 @@ public abstract class ForkedStrategy implements ExecutionStrategy {
         command.add("-cp");
         command.add(task.resolveJavaTools().getAbsolutePath());
         command.add(task.getJavaLauncherClassName());
-        command.addAll(Arrays.asList(programArgs));
+        command.addAll(List.of(programArgs));
         final ProcessBuilder pb = new ProcessBuilder(command).directory(projectDir);
         if (task.hasVerboseLogging()) {
             logger.lifecycle("[plugin] Forked process command: {}", String.join(" ", command));

