diff --git a/javatools/src/main/java/org/xvm/asm/ClassStructure.java b/javatools/src/main/java/org/xvm/asm/ClassStructure.java
index 1bc103e5c..507c8901c 100644
@@ -561,7 +561,7 @@ public class ClassStructure
     public List<Map.Entry<StringConstant, TypeConstant>> getTypeParamsAsList() {
         ListMap<StringConstant, TypeConstant> mapThis = m_mapParams;
         return mapThis == null
-                ? Collections.emptyList()
+                ? List.of()
                 : mapThis.asList();
     }
 
@@ -916,7 +916,7 @@ public class ClassStructure
                 }
             }
         }
-        return Collections.emptyList();
+        return List.of();
     }
 
 
@@ -2616,7 +2616,7 @@ public class ClassStructure
                     }
 
                     if (!typeRight.containsSubstitutableMethod(sig,
-                            accessRight, false, Collections.emptyList())) {
+                            accessRight, false, List.of())) {
                         setMiss.add(sig);
                     }
                 }
@@ -2639,7 +2639,7 @@ public class ClassStructure
 
                         // funky interface scenario
                         if (!typeRight.containsSubstitutableMethod(sig,
-                                accessRight, true, Collections.emptyList())) {
+                                accessRight, true, List.of())) {
                             setMiss.add(sig);
                         }
                     } else {
@@ -2651,7 +2651,7 @@ public class ClassStructure
                         }
 
                         if (!typeRight.containsSubstitutableMethod(sig,
-                                accessRight, false, Collections.emptyList())) {
+                                accessRight, false, List.of())) {
                             setMiss.add(sig);
                         }
                     }
@@ -2782,7 +2782,7 @@ public class ClassStructure
                 typeContrib = contrib.resolveGenerics(pool, new SimpleTypeResolver(pool, listParams));
 
                 if (typeContrib.containsSubstitutableMethod(signature, access, fFunction,
-                        Collections.emptyList())) {
+                        List.of())) {
                     return true;
                 }
             }
@@ -2791,7 +2791,7 @@ public class ClassStructure
         // finally check for Object methods (since Object is always an implicit contribution)
         IdentityConstant idObject = pool.clzObject();
         return !idClass.equals(idObject) && ((ClassStructure) idObject.getComponent()).
-                containsSubstitutableMethod(pool, signature, access, fFunction, Collections.emptyList());
+                containsSubstitutableMethod(pool, signature, access, fFunction, List.of());
     }
 
 
diff --git a/javatools/src/main/java/org/xvm/asm/Component.java b/javatools/src/main/java/org/xvm/asm/Component.java
index f6f70ba6a..8d998ada0 100644
@@ -463,7 +463,7 @@ public abstract class Component
     public List<Contribution> getContributionsAsList() {
         List<Contribution> list = m_listContribs;
         if (list == null) {
-            return Collections.emptyList();
+            return List.of();
         }
         assert (list = Collections.unmodifiableList(m_listContribs)) != null;
         return list;
@@ -1601,7 +1601,7 @@ public abstract class Component
             }
         }
 
-        return matches == null ? Collections.emptyList() : matches;
+        return matches == null ? List.of() : matches;
     }
 
     protected boolean canBeSeen(Access access) {
diff --git a/javatools/src/main/java/org/xvm/asm/ConstantPool.java b/javatools/src/main/java/org/xvm/asm/ConstantPool.java
index c4956ae4d..17f288e94 100755
@@ -2299,7 +2299,7 @@ public class ConstantPool
                 typeObject(), 0, null, 0, true, Collections.emptyMap(),
                 Annotation.NO_ANNOTATIONS, Annotation.NO_ANNOTATIONS,
                 typeObject(), null, typeObject(),
-                Collections.emptyList(), new ListMap<>(), new ListMap<>(),
+                List.of(), new ListMap<>(), new ListMap<>(),
                 Collections.emptyMap(), Collections.emptyMap(),
                 Collections.emptyMap(), Collections.emptyMap(),
                 ListMap.EMPTY, null, Progress.Building) {
@@ -2987,7 +2987,7 @@ public class ConstantPool
     List<TypeConstant> takeDeferredTypeInfo() {
         List<TypeConstant> list = f_tlolistDeferred.get();
         if (list == null) {
-            list = Collections.emptyList();
+            list = List.of();
         } else {
             f_tlolistDeferred.remove();
         }
@@ -3084,7 +3084,7 @@ public class ConstantPool
             // ConditionalTuple to Tuple<Boolean>
             List<TypeConstant> listRight = tupleRight.getParamsCount() > 0
                     ? tupleRight.getParamTypes()
-                    : Collections.singletonList(typeBoolean());
+                    : List.of(typeBoolean());
 
             return clzTuple.calculateAssignability(this, tupleLeft.getParamTypes(), Access.PUBLIC,
                     listRight);
@@ -3514,7 +3514,7 @@ public class ConstantPool
                 null,                   // typeExtends
                 null,                   // typeRebase
                 null,                   // typeInto
-                Collections.emptyList(), // listProcess,
+                List.of(), // listProcess,
                 ListMap.EMPTY,          // listmapClassChain
                 ListMap.EMPTY,          // listmapDefaultChain
                 Collections.emptyMap(),  // mapProps
diff --git a/javatools/src/main/java/org/xvm/asm/constants/AbstractDependantChildTypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/AbstractDependantChildTypeConstant.java
index 824e170a0..d3eed3830 100644
@@ -159,7 +159,7 @@ public abstract class AbstractDependantChildTypeConstant
         TypeConstant type;
         if (typeParent.containsGenericParam(sName)) {
             // the passed in list applies only to the child and should not be used by the parent
-            type = typeParent.getGenericParamType(sName, Collections.emptyList());
+            type = typeParent.getGenericParamType(sName, List.of());
         } else {
             TypeConstant typeActual = listParams.isEmpty()
                     ? this
diff --git a/javatools/src/main/java/org/xvm/asm/constants/ParameterizedTypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/ParameterizedTypeConstant.java
index 706ccacb3..808538d42 100644
@@ -158,7 +158,7 @@ public class ParameterizedTypeConstant
     @Override
     public List<TypeConstant> getParamTypes() {
         return m_atypeParams.length == 0
-                ? Collections.emptyList()
+                ? List.of()
                 : Arrays.asList(m_atypeParams);
     }
 
diff --git a/javatools/src/main/java/org/xvm/asm/constants/PropertyClassTypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/PropertyClassTypeConstant.java
index 010f8f089..b442acd35 100644
@@ -211,7 +211,7 @@ public class PropertyClassTypeConstant
                 : null;
         return type == null
                 // the passed in list represents the "child" and should not be used by the parent
-                ? m_typeParent.getGenericParamType(sName, Collections.emptyList())
+                ? m_typeParent.getGenericParamType(sName, List.of())
                 : type.containsGenericType(true)
                     ? type.resolveGenerics(getConstantPool(), m_typeParent)
                     : type;
@@ -373,7 +373,7 @@ public class PropertyClassTypeConstant
         return new TypeInfo(this, cInvals, infoBase.getClassStructure(),
                 idBase.getNestedDepth() + 1, false, mapTypeParams,
                 Annotation.NO_ANNOTATIONS, infoBase.getMixinAnnotations(), typeBase, null, null,
-                Collections.emptyList(), ListMap.EMPTY, ListMap.EMPTY,
+                List.of(), ListMap.EMPTY, ListMap.EMPTY,
                 mapProps, mapMethods, mapVirtProps, mapVirtMethods, mapChildren,
                 null, TypeInfo.Progress.Complete);
     }
diff --git a/javatools/src/main/java/org/xvm/asm/constants/RelationalTypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/RelationalTypeConstant.java
index 1aa37c43e..50d6989eb 100644
@@ -500,7 +500,7 @@ public abstract class RelationalTypeConstant
                             null,                   // typeExtends
                             null,                   // typeRebase
                             null,                   // typeInto
-                            Collections.emptyList(), // listProcess,
+                            List.of(), // listProcess,
                             ListMap.EMPTY,          // listmapClassChain
                             ListMap.EMPTY,          // listmapDefaultChain
                             mergeProperties(info1, info2, errs),
diff --git a/javatools/src/main/java/org/xvm/asm/constants/TypeCollector.java b/javatools/src/main/java/org/xvm/asm/constants/TypeCollector.java
index b250bfa60..88d1e1064 100644
@@ -90,7 +90,7 @@ public class TypeCollector {
         }
 
         assert m_listMulti == null;
-        return Collections.emptyList();
+        return List.of();
     }
 
     /**
@@ -123,7 +123,7 @@ public class TypeCollector {
         }
 
         return m_listSingle == null
-                ? Collections.emptyList()
+                ? List.of()
                 : ensureMulti();
     }
 
diff --git a/javatools/src/main/java/org/xvm/asm/constants/TypeConstant.java b/javatools/src/main/java/org/xvm/asm/constants/TypeConstant.java
index 90512a656..9eafe781b 100644
@@ -144,7 +144,7 @@ public abstract class TypeConstant
 
     @Override
     public TypeConstant resolveGenericType(String sFormalName) {
-        return getGenericParamType(sFormalName, Collections.emptyList());
+        return getGenericParamType(sFormalName, List.of());
     }
 
 
@@ -436,7 +436,7 @@ public abstract class TypeConstant
     public List<TypeConstant> getParamTypes() {
         return isModifyingType()
                 ? getUnderlyingType().getParamTypes()
-                : Collections.emptyList();
+                : List.of();
     }
 
     /**
@@ -4296,7 +4296,7 @@ public abstract class TypeConstant
                 }
             }
         }
-        return listMatch == null ? Collections.emptyList() : listMatch;
+        return listMatch == null ? List.of() : listMatch;
     }
 
     /**
@@ -4357,7 +4357,7 @@ public abstract class TypeConstant
                 }
             }
         }
-        return listMatch == null ? Collections.emptyList() : listMatch;
+        return listMatch == null ? List.of() : listMatch;
     }
 
     /**
@@ -5614,7 +5614,7 @@ public abstract class TypeConstant
 
         return typeLeftN.isDuckTypeAbleFrom(typeRightN) &&
                typeLeftN.isInterfaceAssignableFrom(
-                        typeRightN, accessRight, Collections.emptyList()).isEmpty()
+                        typeRightN, accessRight, List.of()).isEmpty()
                 ? Relation.IS_A
                 : Relation.INCOMPATIBLE;
     }
@@ -5872,7 +5872,7 @@ public abstract class TypeConstant
         if (usage == null) {
             mapUsage.put(sTypeName, Usage.IN_PROGRESS);
             try {
-                usage = checkConsumption(sTypeName, access, Collections.emptyList());
+                usage = checkConsumption(sTypeName, access, List.of());
             } catch (RuntimeException | Error e) {
                 mapUsage.remove(sTypeName);
                 throw e;
@@ -5918,7 +5918,7 @@ public abstract class TypeConstant
         if (usage == null) {
             mapUsage.put(sTypeName, Usage.IN_PROGRESS);
             try {
-                usage = checkProduction(sTypeName, access, Collections.emptyList());
+                usage = checkProduction(sTypeName, access, List.of());
             } catch (RuntimeException | Error e) {
                 mapUsage.remove(sTypeName);
                 throw e;
@@ -7120,8 +7120,8 @@ public abstract class TypeConstant
                         }
 
                         String       sName      = constName.getValue();
-                        TypeConstant typePLeft  = typeLeft.getGenericParamType(sName, Collections.emptyList());
-                        TypeConstant typePRight = typeRight.getGenericParamType(sName, Collections.emptyList());
+                        TypeConstant typePLeft  = typeLeft.getGenericParamType(sName, List.of());
+                        TypeConstant typePRight = typeRight.getGenericParamType(sName, List.of());
 
                         if (!Objects.equals(typePRight, typePLeft)) {
                             return false;
diff --git a/javatools/src/main/java/org/xvm/compiler/Parser.java b/javatools/src/main/java/org/xvm/compiler/Parser.java
index 9968dae88..ae4a1a798 100644
@@ -428,7 +428,7 @@ public class Parser {
                                 paramnames  = new ArrayList<>();
                                 for (Parameter param : params) {
                                     Token       tokName       = param.getNameToken();
-                                    List<Token> listParamName = Collections.singletonList(tokName);
+                                    List<Token> listParamName = List.of(tokName);
                                     paramnames.add(new NamedTypeExpression(null, listParamName,
                                             null, null, null, tokName.getEndPosition()));
                                 }
@@ -942,7 +942,7 @@ public class Parser {
                 // '<' indicates redundant return type list
                 // '(' indicates parameters
                 return parseMethodDeclarationAfterName(lStartPos, exprCondition, doc, modifiers,
-                        annotations, null, null, Collections.singletonList(new Parameter(type)), name);
+                        annotations, null, null, List.of(new Parameter(type)), name);
             } else {
                 if (fInMethod && modifiers == null) {
                     return parseVariableDeclarationAfterName(annotations, type, name);
@@ -1119,7 +1119,7 @@ public class Parser {
             MethodDeclarationStatement method = new MethodDeclarationStatement(
                     methodName.getStartPosition(), block.getEndPosition(), null, null, null, null,
                     null, null, methodName, null, params, block, null, null, null);
-            body    = new StatementBlock(Collections.singletonList(method),
+            body    = new StatementBlock(List.of(method),
                     method.getStartPosition(), method.getEndPosition());
             lEndPos = body.getEndPosition();
         } else if (peek(Id.L_CURLY)) {
@@ -3040,7 +3040,7 @@ public class Parser {
 
                     if (expr instanceof NamedTypeExpression) {
                         expr = new NamedTypeExpression((NamedTypeExpression) expr,
-                                Collections.singletonList(name), params, lEndPos);
+                                List.of(name), params, lEndPos);
                     } else {
                         expr = new NameExpression(expr, noDeRef, name, params, lEndPos);
                     }
@@ -3147,7 +3147,7 @@ public class Parser {
                     dims    = args.size();
                     lEndPos = prev().getEndPosition();
                 } else {
-                    args = Collections.emptyList();
+                    args = List.of();
                 }
 
                 // parenthesized arguments after the dims
@@ -3219,7 +3219,7 @@ public class Parser {
         case ANY: {
             IgnoredNameExpression exprIgnore = new IgnoredNameExpression(current());
             return peek(Id.LAMBDA)
-                    ? new LambdaExpression(Collections.singletonList(exprIgnore),
+                    ? new LambdaExpression(List.of(exprIgnore),
                         expect(Id.LAMBDA), parseLambdaBody(), exprIgnore.getStartPosition())
                     : exprIgnore;
         }
@@ -3321,7 +3321,7 @@ public class Parser {
 
             // test for single-param implicit lambda
             if (fNormal && peek(Id.LAMBDA)) {
-                return new LambdaExpression(Collections.singletonList(new NameExpression(name)),
+                return new LambdaExpression(List.of(new NameExpression(name)),
                         expect(Id.LAMBDA), parseLambdaBody(), name.getStartPosition());
             }
 
@@ -3442,7 +3442,7 @@ public class Parser {
                 Token lambdaOp = match(Id.LAMBDA);
                 if (lambdaOp != null) {
                     // zero-argument lambda
-                    return new LambdaExpression(Collections.emptyList(), lambdaOp,
+                    return new LambdaExpression(List.of(), lambdaOp,
                             parseLambdaBody(), tokLParen.getStartPosition());
                 } else {
                     // the empty tuple: "()" (or the empty tuple with a trailing comma: "(,)")
@@ -3475,7 +3475,7 @@ public class Parser {
                 // lambda (it's not a tuple literal)
                 expect(Id.R_PAREN);
                 if (peek(Id.LAMBDA)) {
-                    return new LambdaExpression(Collections.singletonList(expr),
+                    return new LambdaExpression(List.of(expr),
                             expect(Id.LAMBDA), parseLambdaBody(), tokLParen.getStartPosition());
                 } else {
                     // just a parenthesized expression
@@ -3642,7 +3642,7 @@ public class Parser {
 
     private static List<Token> toList(NameExpression left, Token name) {
         if (left == null) {
-            return Collections.singletonList(name);
+            return List.of(name);
         }
 
         List<Token> names = left.getNameTokens();
@@ -3777,7 +3777,7 @@ public class Parser {
 
         Token fakeReturn = new Token(firstToken.getStartPosition(), firstToken.getStartPosition(), Id.RETURN);
         ReturnStatement stmt = new ReturnStatement(fakeReturn, parseExpression());
-        return new StatementBlock(Collections.singletonList(stmt), stmt.getStartPosition(), stmt.getEndPosition());
+        return new StatementBlock(List.of(stmt), stmt.getStartPosition(), stmt.getEndPosition());
     }
 
     /**
@@ -3999,7 +3999,7 @@ public class Parser {
                             long           ofMap    = tokOpen.getStartPosition();
                             Token          tokName  = new Token(ofMap, ofMap, Id.IDENTIFIER, "Map");
                             TypeExpression exprType = new NamedTypeExpression(null,
-                                    Collections.singletonList(tokName), null, null, null, ofMap);
+                                    List.of(tokName), null, null, null, ofMap);
                             return new MapExpression(exprType, keys, values, prev().getEndPosition());
                         }
                     }
@@ -4485,7 +4485,7 @@ public class Parser {
         if (!fRequired) {
             Token tokTest = match(Id.IDENTIFIER);
             if (tokTest == null) {
-                return Collections.emptyList();
+                return List.of();
             } else {
                 putBack(tokTest);
             }
@@ -4726,7 +4726,7 @@ public class Parser {
         List<TypeExpression> types = null;
         if (match(Id.COMP_LT, required) != null) {
             if (match(Id.COMP_GT) != null) {
-                types = Collections.emptyList();
+                types = List.of();
             } else {
                 types = parseTypeExpressionList(fAllowTypeSequence);
                 expect(Id.COMP_GT);
@@ -4866,7 +4866,7 @@ public class Parser {
         List<TypeExpression> types = null;
         if (match(Id.L_PAREN, required) != null) {
             types = peek(Id.R_PAREN)
-                    ? Collections.emptyList()
+                    ? List.of()
                     : parseTypeExpressionList(false);
             expect(Id.R_PAREN);
         }
@@ -5011,9 +5011,9 @@ public class Parser {
     List<Parameter> parseReturnList() {
         List<Parameter> listReturn;
         if (match(Id.VOID) != null) {
-            listReturn = Collections.emptyList();
+            listReturn = List.of();
         } else if (match(Id.L_PAREN) == null) {
-            listReturn = Collections.singletonList(new Parameter(parseTypeExpression()));
+            listReturn = List.of(new Parameter(parseTypeExpression()));
         } else {
             listReturn = new ArrayList<>();
             do {
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/AnnotationExpression.java b/javatools/src/main/java/org/xvm/compiler/ast/AnnotationExpression.java
index bdb264366..3194ecf1a 100644
@@ -71,7 +71,7 @@ public class AnnotationExpression
         NamedTypeExpression exprType = type;
         if (exprType == null) {
             assert m_node != null && m_anno != null;
-            List<Token> names = Collections.singletonList(new Token(lStartPos, lEndPos,
+            List<Token> names = List.of(new Token(lStartPos, lEndPos,
                     Id.IDENTIFIER, ((IdentityConstant) m_anno.getAnnotationClass()).getName()));
             exprType = new NamedTypeExpression(null, names, null, null, null, lEndPos);
             exprType.setParent(getParent());
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/AnonInnerClass.java b/javatools/src/main/java/org/xvm/compiler/ast/AnonInnerClass.java
index 1d384bdea..7c9f6570e 100644
@@ -89,14 +89,14 @@ public class AnonInnerClass {
      * @return the Contributions suggested for the anonymous inner class
      */
     public List<CompositionNode> getCompositions() {
-        return m_listCompositions == null ? Collections.emptyList() : m_listCompositions;
+        return m_listCompositions == null ? List.of() : m_listCompositions;
     }
 
     /**
      * @return the Annotations suggested for the anonymous inner class
      */
     public List<AnnotationExpression> getAnnotations() {
-        return m_listAnnos == null ? Collections.emptyList() : m_listAnnos;
+        return m_listAnnos == null ? List.of() : m_listAnnos;
     }
 
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/AssertStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/AssertStatement.java
index 58d138475..828a87b29 100644
@@ -77,7 +77,7 @@ public class AssertStatement
 
         this.keyword  = keyword;
         this.interval = exprInterval;
-        this.conds    = conds == null ? Collections.emptyList() : conds;
+        this.conds    = conds == null ? List.of() : conds;
         this.message  = exprMsg;
         this.lEndPos  = lEndPos;
     }
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/AstNode.java b/javatools/src/main/java/org/xvm/compiler/ast/AstNode.java
index e82fd49d7..12e561a9c 100644
@@ -1748,7 +1748,7 @@ public abstract class AstNode
             }
             case null, default -> {
                 cKids = 1;
-                iterK = Collections.singletonList(value).iterator();
+                iterK = List.of(value).iterator();
             }
             }
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/CompositionNode.java b/javatools/src/main/java/org/xvm/compiler/ast/CompositionNode.java
index cea023dc0..7658846e1 100644
@@ -464,7 +464,7 @@ public abstract class CompositionNode
          */
         public List<Version> getPreferVersionList() {
             if (vers == null) {
-                return Collections.emptyList();
+                return List.of();
             }
 
             List<Version> list = new ArrayList<>();
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/ConditionalStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/ConditionalStatement.java
index 046e96311..cabcac27d 100644
@@ -16,7 +16,7 @@ public abstract class ConditionalStatement
 
     public ConditionalStatement(Token keyword, List<AstNode> conds) {
         this.keyword = keyword;
-        this.conds   = conds  == null ? Collections.emptyList() : conds;
+        this.conds   = conds  == null ? List.of() : conds;
     }
 
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/ForEachStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/ForEachStatement.java
index f28ea5fef..58cefbdc7 100644
@@ -63,7 +63,7 @@ public class ForEachStatement
     // ----- constructors --------------------------------------------------------------------------
 
     public ForEachStatement(Token keyword, AssignmentStatement cond, StatementBlock block) {
-        super(keyword, Collections.singletonList(cond));
+        super(keyword, List.of(cond));
         this.block = block;
     }
 
@@ -295,7 +295,7 @@ public class ForEachStatement
             boolean fValid = true;
 
             // clone the condition(s) and the body
-            conds = Collections.singletonList(condOrig.clone());
+            conds = List.of(condOrig.clone());
             block = (StatementBlock) blockOrig.clone();
 
             // create a temporary error list
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/ForStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/ForStatement.java
index 5b7b9aea6..162373f7d 100644
@@ -58,8 +60,8 @@ public class ForStatement
             List<Statement> update,
             StatementBlock  block) {
         super(keyword, conds);
-        this.init    = init   == null ? Collections.emptyList() : init;
-        this.update  = update == null ? Collections.emptyList() : update;
+        this.init    = init   == null ? List.of() : init;
+        this.update  = update == null ? List.of() : update;
         this.block   = block;
     }
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/ListExpression.java b/javatools/src/main/java/org/xvm/compiler/ast/ListExpression.java
index 19d3d7b87..146ac2c31 100644
@@ -132,7 +132,7 @@ public class ListExpression
         // an empty map looks like an empty list to the parser
         if (typeRequired.isA(pool.typeMap()) && exprs.isEmpty()) {
             MapExpression exprNew = new MapExpression(new NamedTypeExpression(this, typeRequired),
-                    Collections.emptyList(), Collections.emptyList(), getEndPosition());
+                    List.of(), List.of(), getEndPosition());
             exprNew.setParent(this);
             return exprNew.testFit(ctx, typeRequired, fExhaustive, errs);
         }
@@ -179,7 +179,7 @@ public class ListExpression
         // an empty map looks like an empty list to the parser
         if (typeRequired != null && typeRequired.isA(pool.typeMap()) && exprs.isEmpty()) {
             MapExpression exprNew = new MapExpression(new NamedTypeExpression(this, typeRequired),
-                    Collections.emptyList(), Collections.emptyList(), getEndPosition());
+                    List.of(), List.of(), getEndPosition());
             return replaceThisWith(exprNew).validate(ctx, typeRequired, errs);
         }
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/MethodDeclarationStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/MethodDeclarationStatement.java
index a3ea6ee34..162b22a20 100644
@@ -107,7 +107,7 @@ public class MethodDeclarationStatement
         Token fakeReturn = new Token(expr.getStartPosition(), expr.getStartPosition(), Id.RETURN);
         ReturnStatement stmt = new ReturnStatement(fakeReturn, expr);
         stmt.adopt(expr);
-        body = new StatementBlock(Collections.singletonList(stmt), expr.getStartPosition(), expr.getEndPosition());
+        body = new StatementBlock(List.of(stmt), expr.getStartPosition(), expr.getEndPosition());
         body.adopt(stmt);
 
         adopt(body);
@@ -889,7 +889,7 @@ public class MethodDeclarationStatement
 
         int cDefaults = method.getDefaultParamCount();
         if (cDefaults > 0) {
-            StatementBlock block = adopt(new StatementBlock(Collections.emptyList()));
+            StatementBlock block = adopt(new StatementBlock(List.of()));
 
             RootContext ctxMethod = new RootContext(block, method);
             Context     ctx       = ctxMethod.validatingContext();
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/NamedTypeExpression.java b/javatools/src/main/java/org/xvm/compiler/ast/NamedTypeExpression.java
index 4d4a38966..0e5339ed9 100644
@@ -93,7 +93,7 @@ public class NamedTypeExpression
         this.paramTypes = null;
         this.lStartPos  = exprSource.getStartPosition();
         this.lEndPos    = exprSource.getEndPosition();
-        this.names      = Collections.singletonList(new Token(lStartPos, lEndPos,
+        this.names      = List.of(new Token(lStartPos, lEndPos,
                             Token.Id.IDENTIFIER, type.getValueString())); // used for "toString" only
         setTypeConstant(type);
         setStage(Stage.Validated);
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/StageMgr.java b/javatools/src/main/java/org/xvm/compiler/ast/StageMgr.java
index 0a1b5ea19..ded9d4985 100644
@@ -36,7 +36,7 @@ public class StageMgr {
         assert node != null;
         assert stageTarget != null && stageTarget.isTargetable();
 
-        m_listRevisit = Collections.singletonList(node);
+        m_listRevisit = List.of(node);
         m_target      = stageTarget;
         m_errs        = errs == null ? ErrorListener.BLACKHOLE : errs;
     }
@@ -407,7 +407,7 @@ public class StageMgr {
         List<AstNode> listPrevious = m_listRevisit;
         m_listRevisit = null;
         return listPrevious == null
-                ? Collections.emptyList()
+                ? List.of()
                 : listPrevious;
     }
 
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/TupleExpression.java b/javatools/src/main/java/org/xvm/compiler/ast/TupleExpression.java
index 32068db41..7fbb33ed7 100644
@@ -42,7 +42,7 @@ public class TupleExpression
 
     public TupleExpression(TypeExpression type, List<Expression> exprs, long lStartPos, long lEndPos) {
         this.type        = type;
-        this.exprs       = exprs == null ? Collections.emptyList() : exprs;
+        this.exprs       = exprs == null ? List.of() : exprs;
         this.m_lStartPos = lStartPos;
         this.m_lEndPos   = lEndPos;
     }
diff --git a/javatools/src/main/java/org/xvm/compiler/ast/TypeCompositionStatement.java b/javatools/src/main/java/org/xvm/compiler/ast/TypeCompositionStatement.java
index 720561879..9988027d7 100644
@@ -1262,7 +1262,7 @@ public class TypeCompositionStatement
                     composition.log(errs, Severity.ERROR, Compiler.DUPLICATE_DEFAULT_VALUE, sName);
                 } else {
                     NamedTypeExpression typeDefault = new NamedTypeExpression(null,
-                            Collections.singletonList(name), null, null, null, name.getEndPosition());
+                            List.of(name), null, null, null, name.getEndPosition());
                     Expression exprValue = ((Default) composition).getValueExpression();
 
                     long lStartPos = composition.getStartPosition();
@@ -1270,7 +1270,7 @@ public class TypeCompositionStatement
                     PropertyDeclarationStatement propDefault = new PropertyDeclarationStatement(
                             lStartPos, lEndPos,
                             composition.getCondition(),
-                            Collections.singletonList(new Token(lStartPos, lStartPos, Id.STATIC)),
+                            List.of(new Token(lStartPos, lStartPos, Id.STATIC)),
                             null,
                             typeDefault,
                             composition.keyword,
@@ -2503,7 +2503,7 @@ public class TypeCompositionStatement
     private RootContext createConstructorContext(MethodStructure constructor) {
         StatementBlock blockBody = body;
         if (body == null) {
-            blockBody = adopt(new StatementBlock(Collections.emptyList()));
+            blockBody = adopt(new StatementBlock(List.of()));
         }
         return new RootContext(blockBody, constructor);
     }
diff --git a/javatools/src/main/java/org/xvm/runtime/DebugConsole.java b/javatools/src/main/java/org/xvm/runtime/DebugConsole.java
index 07210e6a6..0dbb8b551 100644
@@ -2252,7 +2252,7 @@ public final class DebugConsole
          * @return read-only list of watches (never null)
          */
         List<Watch> getWatchList() {
-            return m_listWatches == null ? Collections.emptyList() : m_listWatches;
+            return m_listWatches == null ? List.of() : m_listWatches;
         }
 
         /**
diff --git a/javatools/src/main/java/org/xvm/runtime/ObjectHandle.java b/javatools/src/main/java/org/xvm/runtime/ObjectHandle.java
index ad1919dbe..18d5c9592 100644
@@ -887,7 +887,7 @@ public abstract class ObjectHandle
 
         @Override
         public int proceed(Frame frameCaller, Frame.Continuation continuation) {
-            return Utils.initConstants(frameCaller, Collections.singletonList(f_constSingleton),
+            return Utils.initConstants(frameCaller, List.of(f_constSingleton),
                 frame -> {
                     frame.pushStack(f_constSingleton.getHandle());
                     return continuation.proceed(frame);
diff --git a/javatools/src/main/java/org/xvm/runtime/template/_native/mgmt/xContainerLinker.java b/javatools/src/main/java/org/xvm/runtime/template/_native/mgmt/xContainerLinker.java
index 46b8c1ca7..a2eb2fb99 100644
@@ -246,7 +247,7 @@ public class xContainerLinker
     private int completeResolveAndLink(Frame frame, Container container,
                                        ModuleStructure moduleApp, ObjectHandle hProvider, int iReturn) {
         NestedContainer containerNested = new NestedContainer(container,
-                moduleApp.getIdentityConstant(), hProvider, Collections.emptyList());
+                moduleApp.getIdentityConstant(), hProvider, List.of());
         return new CollectResources(containerNested, iReturn).doNext(frame);
     }
 

